// Generated by Construct 2, the HTML5 game and app creator :: http://www.scirra.com
var cr = {};
cr.plugins_ = {};
cr.behaviors = {};
(function(){
cr.seal = function(x)
{
if (Object.seal)
return Object.seal(x);
else
return x;
};
cr.freeze = function(x)
{
if (Object.freeze)
return Object.freeze(x);
else
return x;
};
cr.is_undefined = function (x)
{
return typeof x === "undefined";
};
cr.is_number = function (x)
{
return typeof x === "number";
};
cr.is_string = function (x)
{
return typeof x === "string";
};
cr.isPOT = function (x)
{
return x > 0 && ((x - 1) & x) === 0;
}
cr.vector2 = function (x, y)
{
this.x = x;
this.y = y;
cr.seal(this);
};
var v2Proto = cr.vector2.prototype;
v2Proto.offset = function (px, py)
{
this.x += px;
this.y += py;
return this;
};
v2Proto.mul = function (px, py)
{
this.x *= px;
this.y *= py;
return this;
};
cr.segments_intersect = function(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y)
{
if (Math.max(a1x, a2x) < Math.min(b1x, b2x)
|| Math.min(a1x, a2x) > Math.max(b1x, b2x)
|| Math.max(a1y, a2y) < Math.min(b1y, b2y)
|| Math.min(a1y, a2y) > Math.max(b1y, b2y))
{
return false;
}
var dpx = b1x - a1x + b2x - a2x;
var dpy = b1y - a1y + b2y - a2y;
var qax = a2x - a1x;
var qay = a2y - a1y;
var qbx = b2x - b1x;
var qby = b2y - b1y;
var d = Math.abs(qay * qbx - qby * qax);
var la = qbx * dpy - qby * dpx;
var lb = qax * dpy - qay * dpx;
return Math.abs(la) <= d && Math.abs(lb) <= d;
};
cr.rect = function (left, top, right, bottom)
{
this.set(left, top, right, bottom);
cr.seal(this);
};
var rectProto = cr.rect.prototype;
rectProto.set = function (left, top, right, bottom)
{
this.left = left;
this.top = top;
this.right = right;
this.bottom = bottom;
};
rectProto.width = function ()
{
return this.right - this.left;
};
rectProto.height = function ()
{
return this.bottom - this.top;
};
rectProto.offset = function (px, py)
{
this.left += px;
this.top += py;
this.right += px;
this.bottom += py;
return this;
};
rectProto.intersects_rect = function (rc)
{
return !(rc.right < this.left || rc.bottom < this.top || rc.left > this.right || rc.top > this.bottom);
};
rectProto.contains_pt = function (x, y)
{
return (x >= this.left && x <= this.right) && (y >= this.top && y <= this.bottom);
};
cr.quad = function ()
{
this.tlx = 0;
this.tly = 0;
this.trx = 0;
this.try_ = 0;	// is a keyword otherwise!
this.brx = 0;
this.bry = 0;
this.blx = 0;
this.bly = 0;
cr.seal(this);
};
var quadProto = cr.quad.prototype;
quadProto.set_from_rect = function (rc)
{
this.tlx = rc.left;
this.tly = rc.top;
this.trx = rc.right;
this.try_ = rc.top;
this.brx = rc.right;
this.bry = rc.bottom;
this.blx = rc.left;
this.bly = rc.bottom;
};
quadProto.set_from_rotated_rect = function (rc, a)
{
if (a === 0)
{
this.set_from_rect(rc);
}
else
{
var sin_a = Math.sin(a);
var cos_a = Math.cos(a);
var left_sin_a = rc.left * sin_a;
var top_sin_a = rc.top * sin_a;
var right_sin_a = rc.right * sin_a;
var bottom_sin_a = rc.bottom * sin_a;
var left_cos_a = rc.left * cos_a;
var top_cos_a = rc.top * cos_a;
var right_cos_a = rc.right * cos_a;
var bottom_cos_a = rc.bottom * cos_a;
this.tlx = left_cos_a - top_sin_a;
this.tly = top_cos_a + left_sin_a;
this.trx = right_cos_a - top_sin_a;
this.try_ = top_cos_a + right_sin_a;
this.brx = right_cos_a - bottom_sin_a;
this.bry = bottom_cos_a + right_sin_a;
this.blx = left_cos_a - bottom_sin_a;
this.bly = bottom_cos_a + left_sin_a;
}
};
quadProto.offset = function (px, py)
{
this.tlx += px;
this.tly += py;
this.trx += px;
this.try_ += py;
this.brx += px;
this.bry += py;
this.blx += px;
this.bly += py;
return this;
};
quadProto.bounding_box = function (rc)
{
rc.left =   Math.min(this.tlx, this.trx,  this.brx, this.blx);
rc.top =    Math.min(this.tly, this.try_, this.bry, this.bly);
rc.right =  Math.max(this.tlx, this.trx,  this.brx, this.blx);
rc.bottom = Math.max(this.tly, this.try_, this.bry, this.bly);
};
quadProto.contains_pt = function (x, y)
{
var v0x = this.trx - this.tlx;
var v0y = this.try_ - this.tly;
var v1x = this.brx - this.tlx;
var v1y = this.bry - this.tly;
var v2x = x - this.tlx;
var v2y = y - this.tly;
var dot00 = v0x * v0x + v0y * v0y
var dot01 = v0x * v1x + v0y * v1y
var dot02 = v0x * v2x + v0y * v2y
var dot11 = v1x * v1x + v1y * v1y
var dot12 = v1x * v2x + v1y * v2y
var invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
if ((u >= 0.0) && (v > 0.0) && (u + v < 1))
return true;
v0x = this.blx - this.tlx;
v0y = this.bly - this.tly;
var dot00 = v0x * v0x + v0y * v0y
var dot01 = v0x * v1x + v0y * v1y
var dot02 = v0x * v2x + v0y * v2y
invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
u = (dot11 * dot02 - dot01 * dot12) * invDenom;
v = (dot00 * dot12 - dot01 * dot02) * invDenom;
return (u >= 0.0) && (v > 0.0) && (u + v < 1);
};
quadProto.at = function (i, xory)
{
i = i % 4;
if (i < 0)
i += 4;
switch (i)
{
case 0: return xory ? this.tlx : this.tly;
case 1: return xory ? this.trx : this.try_;
case 2: return xory ? this.brx : this.bry;
case 3: return xory ? this.blx : this.bly;
default: return xory ? this.tlx : this.tly;
}
};
quadProto.midX = function ()
{
return (this.tlx + this.trx  + this.brx + this.blx) / 4;
};
quadProto.midY = function ()
{
return (this.tly + this.try_ + this.bry + this.bly) / 4;
};
quadProto.intersects_quad = function (rhs)
{
var midx = rhs.midX();
var midy = rhs.midY();
if (this.contains_pt(midx, midy))
return true;
midx = this.midX();
midy = this.midY();
if (rhs.contains_pt(midx, midy))
return true;
var a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y;
var i, j;
for (i = 0; i < 4; i++)
{
for (j = 0; j < 4; j++)
{
a1x = this.at(i, true);
a1y = this.at(i, false);
a2x = this.at(i + 1, true);
a2y = this.at(i + 1, false);
b1x = rhs.at(j, true);
b1y = rhs.at(j, false);
b2x = rhs.at(j + 1, true);
b2y = rhs.at(j + 1, false);
if (cr.segments_intersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y))
return true;
}
}
return false;
};
cr.RGB = function (red, green, blue)
{
return Math.max(Math.min(red, 255), 0)
| (Math.max(Math.min(green, 255), 0) << 8)
| (Math.max(Math.min(blue, 255), 0) << 16);
};
cr.GetRValue = function (rgb)
{
return rgb & 0xFF;
};
cr.GetGValue = function (rgb)
{
return (rgb & 0xFF00) >> 8;
};
cr.GetBValue = function (rgb)
{
return (rgb & 0xFF0000) >> 16;
};
cr.shallowCopy = function (a, b, allowOverwrite)
{
var attr;
for (attr in b)
{
if (b.hasOwnProperty(attr))
{
;
a[attr] = b[attr];
}
}
};
cr.arrayRemove = function (arr, index)
{
var i, len;
if (index === 0)					// removing first item
arr.shift();
else if (index === arr.length - 1)	// removing last item
arr.pop();
else
{
for (i = index, len = arr.length - 1; i < len; i++)
arr[i] = arr[i + 1];
arr.length = len;
}
};
cr.arrayFindRemove = function (arr, item)
{
var index = jQuery.inArray(item, arr);
if (index >= 0)
cr.arrayRemove(arr, index);
};
cr.clamp = function(x, a, b)
{
if (x < a)
return a;
else if (x > b)
return b;
else
return x;
};
cr.to_radians = function(x)
{
return x / (180.0 / Math.PI);
};
cr.to_degrees = function(x)
{
return x * (180.0 / Math.PI);
};
cr.clamp_angle_degrees = function (a)
{
var angle = a;
angle %= 360;       // now in (-360, 360) range
if (angle < 0)
angle += 360;   // now in [0, 360) range
return angle;
};
cr.clamp_angle = function (a)
{
var angle = a;
angle %= 2 * Math.PI;       // now in (-2pi, 2pi) range
if (angle < 0)
angle += 2 * Math.PI;   // now in [0, 2pi) range
return angle;
};
cr.to_clamped_degrees = function (x)
{
return cr.clamp_angle_degrees(cr.to_degrees(x));
};
cr.to_clamped_radians = function (x)
{
return cr.clamp_angle(cr.to_radians(x));
};
cr.angleTo = function(x1, y1, x2, y2)
{
var dx = x2 - x1;
var dy = y2 - y1;
return Math.atan2(dy, dx);
};
cr.angleDiff = function (a1, a2)
{
if (a1 === a2)
return 0;
var s1 = Math.sin(a1);
var c1 = Math.cos(a1);
var s2 = Math.sin(a2);
var c2 = Math.cos(a2);
var n = s1 * s2 + c1 * c2;
if (n >= 1)
return 0;
if (n <= -1)
return Math.PI;
return Math.acos(n);
};
cr.angleRotate = function (start, end, step)
{
var ss = Math.sin(start);
var cs = Math.cos(start);
var se = Math.sin(end);
var ce = Math.cos(end);
if (Math.acos(ss * se + cs * ce) > step)
{
if (cs * se - ss * ce > 0)
return cr.clamp_angle(start + step);
else
return cr.clamp_angle(start - step);
}
else
return cr.clamp_angle(end);
};
cr.angleClockwise = function (a1, a2)
{
var s1 = Math.sin(a1);
var c1 = Math.cos(a1);
var s2 = Math.sin(a2);
var c2 = Math.cos(a2);
return c1 * s2 - s1 * c2 <= 0;
};
cr.distanceTo = function(x1, y1, x2, y2)
{
var dx = x2 - x1;
var dy = y2 - y1;
return Math.sqrt(dx*dx + dy*dy);
};
cr.xor = function (x, y)
{
return !x !== !y;
};
cr.lerp = function (a, b, x)
{
return a + (b - a) * x;
};
cr.wipe = function (obj)
{
var p;
for (p in obj)
{
if (obj.hasOwnProperty(p))
delete obj[p];
}
};
cr.ObjectSet = function ()
{
this.items = {};
this.item_count = 0;
this.values_cache = [];
this.cache_valid = true;
cr.seal(this);
};
var ObjectSetProto = cr.ObjectSet.prototype;
ObjectSetProto.contains = function (x)
{
return this.items.hasOwnProperty(x.toString());
};
ObjectSetProto.add = function (x)
{
if (!this.contains(x))
{
this.items[x.toString()] = x;
this.item_count++;
this.cache_valid = false;
}
return this;
};
ObjectSetProto.remove = function (x)
{
if (this.contains(x))
{
delete this.items[x.toString()];
this.item_count--;
this.cache_valid = false;
}
return this;
};
ObjectSetProto.clear = function ()
{
cr.wipe(this.items);
this.item_count = 0;
this.values_cache.length = 0;
this.cache_valid = true;
return this;
};
ObjectSetProto.isEmpty = function ()
{
return this.item_count === 0;
};
ObjectSetProto.count = function ()
{
return this.item_count;
};
ObjectSetProto.update_cache = function ()
{
if (this.cache_valid)
return;
this.values_cache.length = 0;
var i;
for (i in this.items)
{
if (this.items.hasOwnProperty(i))
this.values_cache.push(this.items[i]);
}
this.cache_valid = true;
};
ObjectSetProto.values = function ()
{
this.update_cache();
return this.values_cache.slice(0);
};
ObjectSetProto.valuesRef = function ()
{
this.update_cache();
return this.values_cache;
};
cr.KahanAdder = function ()
{
this.c = 0;
this.y = 0;
this.t = 0;
this.sum = 0;
cr.seal(this);
};
var KahanProto = cr.KahanAdder.prototype;
KahanProto.add = function (v)
{
this.y = v - this.c;
this.t = this.sum + this.y;
this.c = (this.t - this.sum) - this.y;
this.sum = this.t;
};
KahanProto.reset = function ()
{
this.c = 0;
this.y = 0;
this.t = 0;
this.sum = 0;
};
cr.regexp_escape = function(text)
{
return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
};
cr.CollisionPoly = function (pts_array_)
{
this.pts_cache = [];
this.set_pts(pts_array_);
cr.seal(this);
};
var CollisionPolyProto = cr.CollisionPoly.prototype;
CollisionPolyProto.set_pts = function(pts_array_)
{
this.pts_array = pts_array_;
this.pts_count = pts_array_.length / 2;			// x, y, x, y... in array
this.pts_cache.length = pts_array_.length;
this.cache_width = -1;
this.cache_height = -1;
this.cache_angle = 0;
};
CollisionPolyProto.is_empty = function()
{
return !this.pts_array.length;
};
CollisionPolyProto.set_from_quad = function(q, offx, offy, w, h)
{
this.pts_cache.length = 8;
this.pts_count = 4;
this.pts_cache[0] = q.tlx - offx;
this.pts_cache[1] = q.tly - offy;
this.pts_cache[2] = q.trx - offx;
this.pts_cache[3] = q.try_ - offy;
this.pts_cache[4] = q.brx - offx;
this.pts_cache[5] = q.bry - offy;
this.pts_cache[6] = q.blx - offx;
this.pts_cache[7] = q.bly - offy;
this.cache_width = w;
this.cache_height = h;
};
CollisionPolyProto.cache_poly = function(w, h, a)
{
if (this.cache_width === w && this.cache_height === h && this.cache_angle === a)
return;		// cache up-to-date
this.cache_width = w;
this.cache_height = h;
this.cache_angle = a;
var i, len, x, y, x_temp;
var sina = 0;
var cosa = 1;
if (a !== 0)
{
sina = Math.sin(a);
cosa = Math.cos(a);
}
for (i = 0, len = this.pts_count; i < len; i++)
{
x = this.pts_array[i*2] * w;
y = this.pts_array[i*2+1] * h;
this.pts_cache[i*2] = (x * cosa) - (y * sina);
this.pts_cache[i*2+1] = (y * cosa) + (x * sina);
}
};
CollisionPolyProto.contains_pt = function (a2x, a2y)
{
if (a2x === this.pts_cache[0] && a2y === this.pts_cache[1])
return true;
var a1x = -this.cache_width * 5 - 1;
var a1y = -this.cache_height * 5 - 1;
var a3x = this.cache_width * 5 + 1;
var a3y = -1;
var b1x, b1y, b2x, b2y;
var i, len;
var count1 = 0, count2 = 0;
for (i = 0, len = this.pts_count; i < len; i++)
{
b1x = this.pts_cache[i*2];
b1y = this.pts_cache[i*2+1];
b2x = this.pts_cache[((i+1)%len)*2];
b2y = this.pts_cache[((i+1)%len)*2+1];
if (cr.segments_intersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y))
count1++;
if (cr.segments_intersect(a3x, a3y, a2x, a2y, b1x, b1y, b2x, b2y))
count2++;
}
return (count1 % 2 === 1) || (count2 % 2 === 1);
};
CollisionPolyProto.intersects_poly = function (rhs, offx, offy)
{
if (this.contains_pt(rhs.pts_cache[0] + offx, rhs.pts_cache[1] + offy))
return true;
if (rhs.contains_pt(this.pts_cache[0] - offx, this.pts_cache[1] - offy))
return true;
var i, leni, j, lenj;
var a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y;
for (i = 0, leni = this.pts_count; i < leni; i++)
{
a1x = this.pts_cache[i*2];
a1y = this.pts_cache[i*2+1];
a2x = this.pts_cache[((i+1)%leni)*2];
a2y = this.pts_cache[((i+1)%leni)*2+1];
for (j = 0, lenj = rhs.pts_count; j < lenj; j++)
{
b1x = rhs.pts_cache[j*2] + offx;
b1y = rhs.pts_cache[j*2+1] + offy;
b2x = rhs.pts_cache[((j+1)%lenj)*2] + offx;
b2y = rhs.pts_cache[((j+1)%lenj)*2+1] + offy;
if (cr.segments_intersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y))
return true;
}
}
return false;
};
var fxNames = [ "lighter",
"xor",
"copy",
"destination-over",
"source-in",
"destination-in",
"source-out",
"destination-out",
"source-atop",
"destination-atop"];
cr.effectToCompositeOp = function(effect)
{
if (effect <= 0 || effect >= 11)
return "source-over";
return fxNames[effect - 1];	// not including "none" so offset by 1
};
cr.setGLBlend = function(this_, effect, gl)
{
if (!gl)
return;
this_.srcBlend = gl.ONE;
this_.destBlend = gl.ONE_MINUS_SRC_ALPHA;
switch (effect) {
case 1:		// lighter (additive)
this_.srcBlend = gl.ONE;
this_.destBlend = gl.ONE;
break;
case 2:		// xor
break;	// todo
case 3:		// copy
this_.srcBlend = gl.ONE;
this_.destBlend = gl.ZERO;
break;
case 4:		// destination-over
this_.srcBlend = gl.ONE_MINUS_DST_ALPHA;
this_.destBlend = gl.ONE;
break;
case 5:		// source-in
this_.srcBlend = gl.DST_ALPHA;
this_.destBlend = gl.ZERO;
break;
case 6:		// destination-in
this_.srcBlend = gl.ZERO;
this_.destBlend = gl.SRC_ALPHA;
break;
case 7:		// source-out
this_.srcBlend = gl.ONE_MINUS_DST_ALPHA;
this_.destBlend = gl.ZERO;
break;
case 8:		// destination-out
this_.srcBlend = gl.ZERO;
this_.destBlend = gl.ONE_MINUS_SRC_ALPHA;
break;
case 9:		// source-atop
this_.srcBlend = gl.DST_ALPHA;
this_.destBlend = gl.ONE_MINUS_SRC_ALPHA;
break;
case 10:	// destination-atop
this_.srcBlend = gl.ONE_MINUS_DST_ALPHA;
this_.destBlend = gl.SRC_ALPHA;
break;
}	
};
cr.round6dp = function (x)
{
return Math.round(x * 1000000) / 1000000;
};
}());
var MatrixArray=typeof Float32Array!=="undefined"?Float32Array:Array,glMatrixArrayType=MatrixArray,vec3={},mat3={},mat4={},quat4={};vec3.create=function(a){var b=new MatrixArray(3);a&&(b[0]=a[0],b[1]=a[1],b[2]=a[2]);return b};vec3.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];return b};vec3.add=function(a,b,c){if(!c||a===c)return a[0]+=b[0],a[1]+=b[1],a[2]+=b[2],a;c[0]=a[0]+b[0];c[1]=a[1]+b[1];c[2]=a[2]+b[2];return c};
vec3.subtract=function(a,b,c){if(!c||a===c)return a[0]-=b[0],a[1]-=b[1],a[2]-=b[2],a;c[0]=a[0]-b[0];c[1]=a[1]-b[1];c[2]=a[2]-b[2];return c};vec3.negate=function(a,b){b||(b=a);b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];return b};vec3.scale=function(a,b,c){if(!c||a===c)return a[0]*=b,a[1]*=b,a[2]*=b,a;c[0]=a[0]*b;c[1]=a[1]*b;c[2]=a[2]*b;return c};
vec3.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=Math.sqrt(c*c+d*d+e*e);if(g){if(g===1)return b[0]=c,b[1]=d,b[2]=e,b}else return b[0]=0,b[1]=0,b[2]=0,b;g=1/g;b[0]=c*g;b[1]=d*g;b[2]=e*g;return b};vec3.cross=function(a,b,c){c||(c=a);var d=a[0],e=a[1],a=a[2],g=b[0],f=b[1],b=b[2];c[0]=e*b-a*f;c[1]=a*g-d*b;c[2]=d*f-e*g;return c};vec3.length=function(a){var b=a[0],c=a[1],a=a[2];return Math.sqrt(b*b+c*c+a*a)};vec3.dot=function(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]};
vec3.direction=function(a,b,c){c||(c=a);var d=a[0]-b[0],e=a[1]-b[1],a=a[2]-b[2],b=Math.sqrt(d*d+e*e+a*a);if(!b)return c[0]=0,c[1]=0,c[2]=0,c;b=1/b;c[0]=d*b;c[1]=e*b;c[2]=a*b;return c};vec3.lerp=function(a,b,c,d){d||(d=a);d[0]=a[0]+c*(b[0]-a[0]);d[1]=a[1]+c*(b[1]-a[1]);d[2]=a[2]+c*(b[2]-a[2]);return d};vec3.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+"]"};
mat3.create=function(a){var b=new MatrixArray(9);a&&(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3],b[4]=a[4],b[5]=a[5],b[6]=a[6],b[7]=a[7],b[8]=a[8]);return b};mat3.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];return b};mat3.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=1;a[5]=0;a[6]=0;a[7]=0;a[8]=1;return a};
mat3.transpose=function(a,b){if(!b||a===b){var c=a[1],d=a[2],e=a[5];a[1]=a[3];a[2]=a[6];a[3]=c;a[5]=a[7];a[6]=d;a[7]=e;return a}b[0]=a[0];b[1]=a[3];b[2]=a[6];b[3]=a[1];b[4]=a[4];b[5]=a[7];b[6]=a[2];b[7]=a[5];b[8]=a[8];return b};mat3.toMat4=function(a,b){b||(b=mat4.create());b[15]=1;b[14]=0;b[13]=0;b[12]=0;b[11]=0;b[10]=a[8];b[9]=a[7];b[8]=a[6];b[7]=0;b[6]=a[5];b[5]=a[4];b[4]=a[3];b[3]=0;b[2]=a[2];b[1]=a[1];b[0]=a[0];return b};
mat3.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+", "+a[8]+"]"};mat4.create=function(a){var b=new MatrixArray(16);a&&(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3],b[4]=a[4],b[5]=a[5],b[6]=a[6],b[7]=a[7],b[8]=a[8],b[9]=a[9],b[10]=a[10],b[11]=a[11],b[12]=a[12],b[13]=a[13],b[14]=a[14],b[15]=a[15]);return b};
mat4.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return b};mat4.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=1;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=1;a[11]=0;a[12]=0;a[13]=0;a[14]=0;a[15]=1;return a};
mat4.transpose=function(a,b){if(!b||a===b){var c=a[1],d=a[2],e=a[3],g=a[6],f=a[7],h=a[11];a[1]=a[4];a[2]=a[8];a[3]=a[12];a[4]=c;a[6]=a[9];a[7]=a[13];a[8]=d;a[9]=g;a[11]=a[14];a[12]=e;a[13]=f;a[14]=h;return a}b[0]=a[0];b[1]=a[4];b[2]=a[8];b[3]=a[12];b[4]=a[1];b[5]=a[5];b[6]=a[9];b[7]=a[13];b[8]=a[2];b[9]=a[6];b[10]=a[10];b[11]=a[14];b[12]=a[3];b[13]=a[7];b[14]=a[11];b[15]=a[15];return b};
mat4.determinant=function(a){var b=a[0],c=a[1],d=a[2],e=a[3],g=a[4],f=a[5],h=a[6],i=a[7],j=a[8],k=a[9],l=a[10],n=a[11],o=a[12],m=a[13],p=a[14],a=a[15];return o*k*h*e-j*m*h*e-o*f*l*e+g*m*l*e+j*f*p*e-g*k*p*e-o*k*d*i+j*m*d*i+o*c*l*i-b*m*l*i-j*c*p*i+b*k*p*i+o*f*d*n-g*m*d*n-o*c*h*n+b*m*h*n+g*c*p*n-b*f*p*n-j*f*d*a+g*k*d*a+j*c*h*a-b*k*h*a-g*c*l*a+b*f*l*a};
mat4.inverse=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=a[4],h=a[5],i=a[6],j=a[7],k=a[8],l=a[9],n=a[10],o=a[11],m=a[12],p=a[13],r=a[14],s=a[15],A=c*h-d*f,B=c*i-e*f,t=c*j-g*f,u=d*i-e*h,v=d*j-g*h,w=e*j-g*i,x=k*p-l*m,y=k*r-n*m,z=k*s-o*m,C=l*r-n*p,D=l*s-o*p,E=n*s-o*r,q=1/(A*E-B*D+t*C+u*z-v*y+w*x);b[0]=(h*E-i*D+j*C)*q;b[1]=(-d*E+e*D-g*C)*q;b[2]=(p*w-r*v+s*u)*q;b[3]=(-l*w+n*v-o*u)*q;b[4]=(-f*E+i*z-j*y)*q;b[5]=(c*E-e*z+g*y)*q;b[6]=(-m*w+r*t-s*B)*q;b[7]=(k*w-n*t+o*B)*q;b[8]=(f*D-h*z+j*x)*q;
b[9]=(-c*D+d*z-g*x)*q;b[10]=(m*v-p*t+s*A)*q;b[11]=(-k*v+l*t-o*A)*q;b[12]=(-f*C+h*y-i*x)*q;b[13]=(c*C-d*y+e*x)*q;b[14]=(-m*u+p*B-r*A)*q;b[15]=(k*u-l*B+n*A)*q;return b};mat4.toRotationMat=function(a,b){b||(b=mat4.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};
mat4.toMat3=function(a,b){b||(b=mat3.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[4];b[4]=a[5];b[5]=a[6];b[6]=a[8];b[7]=a[9];b[8]=a[10];return b};mat4.toInverseMat3=function(a,b){var c=a[0],d=a[1],e=a[2],g=a[4],f=a[5],h=a[6],i=a[8],j=a[9],k=a[10],l=k*f-h*j,n=-k*g+h*i,o=j*g-f*i,m=c*l+d*n+e*o;if(!m)return null;m=1/m;b||(b=mat3.create());b[0]=l*m;b[1]=(-k*d+e*j)*m;b[2]=(h*d-e*f)*m;b[3]=n*m;b[4]=(k*c-e*i)*m;b[5]=(-h*c+e*g)*m;b[6]=o*m;b[7]=(-j*c+d*i)*m;b[8]=(f*c-d*g)*m;return b};
mat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],f=a[3],h=a[4],i=a[5],j=a[6],k=a[7],l=a[8],n=a[9],o=a[10],m=a[11],p=a[12],r=a[13],s=a[14],a=a[15],A=b[0],B=b[1],t=b[2],u=b[3],v=b[4],w=b[5],x=b[6],y=b[7],z=b[8],C=b[9],D=b[10],E=b[11],q=b[12],F=b[13],G=b[14],b=b[15];c[0]=A*d+B*h+t*l+u*p;c[1]=A*e+B*i+t*n+u*r;c[2]=A*g+B*j+t*o+u*s;c[3]=A*f+B*k+t*m+u*a;c[4]=v*d+w*h+x*l+y*p;c[5]=v*e+w*i+x*n+y*r;c[6]=v*g+w*j+x*o+y*s;c[7]=v*f+w*k+x*m+y*a;c[8]=z*d+C*h+D*l+E*p;c[9]=z*e+C*i+D*n+E*r;c[10]=z*g+C*
j+D*o+E*s;c[11]=z*f+C*k+D*m+E*a;c[12]=q*d+F*h+G*l+b*p;c[13]=q*e+F*i+G*n+b*r;c[14]=q*g+F*j+G*o+b*s;c[15]=q*f+F*k+G*m+b*a;return c};mat4.multiplyVec3=function(a,b,c){c||(c=b);var d=b[0],e=b[1],b=b[2];c[0]=a[0]*d+a[4]*e+a[8]*b+a[12];c[1]=a[1]*d+a[5]*e+a[9]*b+a[13];c[2]=a[2]*d+a[6]*e+a[10]*b+a[14];return c};
mat4.multiplyVec4=function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2],b=b[3];c[0]=a[0]*d+a[4]*e+a[8]*g+a[12]*b;c[1]=a[1]*d+a[5]*e+a[9]*g+a[13]*b;c[2]=a[2]*d+a[6]*e+a[10]*g+a[14]*b;c[3]=a[3]*d+a[7]*e+a[11]*g+a[15]*b;return c};
mat4.translate=function(a,b,c){var d=b[0],e=b[1],b=b[2],g,f,h,i,j,k,l,n,o,m,p,r;if(!c||a===c)return a[12]=a[0]*d+a[4]*e+a[8]*b+a[12],a[13]=a[1]*d+a[5]*e+a[9]*b+a[13],a[14]=a[2]*d+a[6]*e+a[10]*b+a[14],a[15]=a[3]*d+a[7]*e+a[11]*b+a[15],a;g=a[0];f=a[1];h=a[2];i=a[3];j=a[4];k=a[5];l=a[6];n=a[7];o=a[8];m=a[9];p=a[10];r=a[11];c[0]=g;c[1]=f;c[2]=h;c[3]=i;c[4]=j;c[5]=k;c[6]=l;c[7]=n;c[8]=o;c[9]=m;c[10]=p;c[11]=r;c[12]=g*d+j*e+o*b+a[12];c[13]=f*d+k*e+m*b+a[13];c[14]=h*d+l*e+p*b+a[14];c[15]=i*d+n*e+r*b+a[15];
return c};mat4.scale=function(a,b,c){var d=b[0],e=b[1],b=b[2];if(!c||a===c)return a[0]*=d,a[1]*=d,a[2]*=d,a[3]*=d,a[4]*=e,a[5]*=e,a[6]*=e,a[7]*=e,a[8]*=b,a[9]*=b,a[10]*=b,a[11]*=b,a;c[0]=a[0]*d;c[1]=a[1]*d;c[2]=a[2]*d;c[3]=a[3]*d;c[4]=a[4]*e;c[5]=a[5]*e;c[6]=a[6]*e;c[7]=a[7]*e;c[8]=a[8]*b;c[9]=a[9]*b;c[10]=a[10]*b;c[11]=a[11]*b;c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15];return c};
mat4.rotate=function(a,b,c,d){var e=c[0],g=c[1],c=c[2],f=Math.sqrt(e*e+g*g+c*c),h,i,j,k,l,n,o,m,p,r,s,A,B,t,u,v,w,x,y,z;if(!f)return null;f!==1&&(f=1/f,e*=f,g*=f,c*=f);h=Math.sin(b);i=Math.cos(b);j=1-i;b=a[0];f=a[1];k=a[2];l=a[3];n=a[4];o=a[5];m=a[6];p=a[7];r=a[8];s=a[9];A=a[10];B=a[11];t=e*e*j+i;u=g*e*j+c*h;v=c*e*j-g*h;w=e*g*j-c*h;x=g*g*j+i;y=c*g*j+e*h;z=e*c*j+g*h;e=g*c*j-e*h;g=c*c*j+i;d?a!==d&&(d[12]=a[12],d[13]=a[13],d[14]=a[14],d[15]=a[15]):d=a;d[0]=b*t+n*u+r*v;d[1]=f*t+o*u+s*v;d[2]=k*t+m*u+A*
v;d[3]=l*t+p*u+B*v;d[4]=b*w+n*x+r*y;d[5]=f*w+o*x+s*y;d[6]=k*w+m*x+A*y;d[7]=l*w+p*x+B*y;d[8]=b*z+n*e+r*g;d[9]=f*z+o*e+s*g;d[10]=k*z+m*e+A*g;d[11]=l*z+p*e+B*g;return d};mat4.rotateX=function(a,b,c){var d=Math.sin(b),b=Math.cos(b),e=a[4],g=a[5],f=a[6],h=a[7],i=a[8],j=a[9],k=a[10],l=a[11];c?a!==c&&(c[0]=a[0],c[1]=a[1],c[2]=a[2],c[3]=a[3],c[12]=a[12],c[13]=a[13],c[14]=a[14],c[15]=a[15]):c=a;c[4]=e*b+i*d;c[5]=g*b+j*d;c[6]=f*b+k*d;c[7]=h*b+l*d;c[8]=e*-d+i*b;c[9]=g*-d+j*b;c[10]=f*-d+k*b;c[11]=h*-d+l*b;return c};
mat4.rotateY=function(a,b,c){var d=Math.sin(b),b=Math.cos(b),e=a[0],g=a[1],f=a[2],h=a[3],i=a[8],j=a[9],k=a[10],l=a[11];c?a!==c&&(c[4]=a[4],c[5]=a[5],c[6]=a[6],c[7]=a[7],c[12]=a[12],c[13]=a[13],c[14]=a[14],c[15]=a[15]):c=a;c[0]=e*b+i*-d;c[1]=g*b+j*-d;c[2]=f*b+k*-d;c[3]=h*b+l*-d;c[8]=e*d+i*b;c[9]=g*d+j*b;c[10]=f*d+k*b;c[11]=h*d+l*b;return c};
mat4.rotateZ=function(a,b,c){var d=Math.sin(b),b=Math.cos(b),e=a[0],g=a[1],f=a[2],h=a[3],i=a[4],j=a[5],k=a[6],l=a[7];c?a!==c&&(c[8]=a[8],c[9]=a[9],c[10]=a[10],c[11]=a[11],c[12]=a[12],c[13]=a[13],c[14]=a[14],c[15]=a[15]):c=a;c[0]=e*b+i*d;c[1]=g*b+j*d;c[2]=f*b+k*d;c[3]=h*b+l*d;c[4]=e*-d+i*b;c[5]=g*-d+j*b;c[6]=f*-d+k*b;c[7]=h*-d+l*b;return c};
mat4.frustum=function(a,b,c,d,e,g,f){f||(f=mat4.create());var h=b-a,i=d-c,j=g-e;f[0]=e*2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=e*2/i;f[6]=0;f[7]=0;f[8]=(b+a)/h;f[9]=(d+c)/i;f[10]=-(g+e)/j;f[11]=-1;f[12]=0;f[13]=0;f[14]=-(g*e*2)/j;f[15]=0;return f};mat4.perspective=function(a,b,c,d,e){a=c*Math.tan(a*Math.PI/360);b*=a;return mat4.frustum(-b,b,-a,a,c,d,e)};
mat4.ortho=function(a,b,c,d,e,g,f){f||(f=mat4.create());var h=b-a,i=d-c,j=g-e;f[0]=2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=2/i;f[6]=0;f[7]=0;f[8]=0;f[9]=0;f[10]=-2/j;f[11]=0;f[12]=-(a+b)/h;f[13]=-(d+c)/i;f[14]=-(g+e)/j;f[15]=1;return f};
mat4.lookAt=function(a,b,c,d){d||(d=mat4.create());var e,g,f,h,i,j,k,l,n=a[0],o=a[1],a=a[2];g=c[0];f=c[1];e=c[2];c=b[1];j=b[2];if(n===b[0]&&o===c&&a===j)return mat4.identity(d);c=n-b[0];j=o-b[1];k=a-b[2];l=1/Math.sqrt(c*c+j*j+k*k);c*=l;j*=l;k*=l;b=f*k-e*j;e=e*c-g*k;g=g*j-f*c;(l=Math.sqrt(b*b+e*e+g*g))?(l=1/l,b*=l,e*=l,g*=l):g=e=b=0;f=j*g-k*e;h=k*b-c*g;i=c*e-j*b;(l=Math.sqrt(f*f+h*h+i*i))?(l=1/l,f*=l,h*=l,i*=l):i=h=f=0;d[0]=b;d[1]=f;d[2]=c;d[3]=0;d[4]=e;d[5]=h;d[6]=j;d[7]=0;d[8]=g;d[9]=i;d[10]=k;d[11]=
0;d[12]=-(b*n+e*o+g*a);d[13]=-(f*n+h*o+i*a);d[14]=-(c*n+j*o+k*a);d[15]=1;return d};mat4.fromRotationTranslation=function(a,b,c){c||(c=mat4.create());var d=a[0],e=a[1],g=a[2],f=a[3],h=d+d,i=e+e,j=g+g,a=d*h,k=d*i;d*=j;var l=e*i;e*=j;g*=j;h*=f;i*=f;f*=j;c[0]=1-(l+g);c[1]=k+f;c[2]=d-i;c[3]=0;c[4]=k-f;c[5]=1-(a+g);c[6]=e+h;c[7]=0;c[8]=d+i;c[9]=e-h;c[10]=1-(a+l);c[11]=0;c[12]=b[0];c[13]=b[1];c[14]=b[2];c[15]=1;return c};
mat4.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+", "+a[8]+", "+a[9]+", "+a[10]+", "+a[11]+", "+a[12]+", "+a[13]+", "+a[14]+", "+a[15]+"]"};quat4.create=function(a){var b=new MatrixArray(4);a&&(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3]);return b};quat4.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];return b};
quat4.calculateW=function(a,b){var c=a[0],d=a[1],e=a[2];if(!b||a===b)return a[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e)),a;b[0]=c;b[1]=d;b[2]=e;b[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e));return b};quat4.inverse=function(a,b){if(!b||a===b)return a[0]*=-1,a[1]*=-1,a[2]*=-1,a;b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];b[3]=a[3];return b};quat4.length=function(a){var b=a[0],c=a[1],d=a[2],a=a[3];return Math.sqrt(b*b+c*c+d*d+a*a)};
quat4.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=Math.sqrt(c*c+d*d+e*e+g*g);if(f===0)return b[0]=0,b[1]=0,b[2]=0,b[3]=0,b;f=1/f;b[0]=c*f;b[1]=d*f;b[2]=e*f;b[3]=g*f;return b};quat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],a=a[3],f=b[0],h=b[1],i=b[2],b=b[3];c[0]=d*b+a*f+e*i-g*h;c[1]=e*b+a*h+g*f-d*i;c[2]=g*b+a*i+d*h-e*f;c[3]=a*b-d*f-e*h-g*i;return c};
quat4.multiplyVec3=function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2],b=a[0],f=a[1],h=a[2],a=a[3],i=a*d+f*g-h*e,j=a*e+h*d-b*g,k=a*g+b*e-f*d,d=-b*d-f*e-h*g;c[0]=i*a+d*-b+j*-h-k*-f;c[1]=j*a+d*-f+k*-b-i*-h;c[2]=k*a+d*-h+i*-f-j*-b;return c};quat4.toMat3=function(a,b){b||(b=mat3.create());var c=a[0],d=a[1],e=a[2],g=a[3],f=c+c,h=d+d,i=e+e,j=c*f,k=c*h;c*=i;var l=d*h;d*=i;e*=i;f*=g;h*=g;g*=i;b[0]=1-(l+e);b[1]=k+g;b[2]=c-h;b[3]=k-g;b[4]=1-(j+e);b[5]=d+f;b[6]=c+h;b[7]=d-f;b[8]=1-(j+l);return b};
quat4.toMat4=function(a,b){b||(b=mat4.create());var c=a[0],d=a[1],e=a[2],g=a[3],f=c+c,h=d+d,i=e+e,j=c*f,k=c*h;c*=i;var l=d*h;d*=i;e*=i;f*=g;h*=g;g*=i;b[0]=1-(l+e);b[1]=k+g;b[2]=c-h;b[3]=0;b[4]=k-g;b[5]=1-(j+e);b[6]=d+f;b[7]=0;b[8]=c+h;b[9]=d-f;b[10]=1-(j+l);b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};
quat4.slerp=function(a,b,c,d){d||(d=a);var e=a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3],g,f;if(Math.abs(e)>=1)return d!==a&&(d[0]=a[0],d[1]=a[1],d[2]=a[2],d[3]=a[3]),d;g=Math.acos(e);f=Math.sqrt(1-e*e);if(Math.abs(f)<0.001)return d[0]=a[0]*0.5+b[0]*0.5,d[1]=a[1]*0.5+b[1]*0.5,d[2]=a[2]*0.5+b[2]*0.5,d[3]=a[3]*0.5+b[3]*0.5,d;e=Math.sin((1-c)*g)/f;c=Math.sin(c*g)/f;d[0]=a[0]*e+b[0]*c;d[1]=a[1]*e+b[1]*c;d[2]=a[2]*e+b[2]*c;d[3]=a[3]*e+b[3]*c;return d};
quat4.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+"]"};
(function()
{
var MAX_VERTICES = 8000;						// equates to 2500 objects being drawn
var MAX_INDICES = (MAX_VERTICES / 2) * 3;		// 6 indices for every 4 vertices
var MAX_POINTS = 8000;
var MULTI_BUFFERS = 2;							// cycle 2 buffers for quads to try and avoid blocking
var BATCH_NULL = 0;
var BATCH_QUAD = 1;
var BATCH_SETTEXTURE = 2;
var BATCH_SETOPACITY = 3;
var BATCH_SETBLEND = 4;
var BATCH_UPDATEMODELVIEW = 5;
var BATCH_RENDERTOTEXTURE = 6;
var BATCH_CLEAR = 7;
var BATCH_POINTS = 8;
cr.GLWrap = function (gl, isMobile)
{
this.gl = gl;
var i, len;
this.width = 0;		// not yet known, wait for call to setSize()
this.height = 0;
this.cam = vec3.create([0, 0, 100]);			// camera position
this.look = vec3.create([0, 0, 0]);				// lookat position
this.up = vec3.create([0, 1, 0]);				// up vector
this.worldScale = vec3.create([1, 1, 1]);		// world scaling factor
this.lastOpacity = 1;
this.lastTexture = null;
gl.clearColor(0, 0, 0, 0);
gl.clear(gl.COLOR_BUFFER_BIT);
gl.enable(gl.BLEND);
gl.disable(gl.CULL_FACE);
gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
gl.disable(gl.DEPTH_TEST);
this.lastSrcBlend = gl.ONE;
this.lastDestBlend = gl.ONE_MINUS_SRC_ALPHA;
this.pointBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, this.pointBuffer);
this.vertexBuffers = new Array(MULTI_BUFFERS);
this.texcoordBuffers = new Array(MULTI_BUFFERS);
for (i = 0; i < MULTI_BUFFERS; i++)
{
this.vertexBuffers[i] = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffers[i]);
this.texcoordBuffers[i] = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffers[i]);
}
this.curBuffer = 0;
this.indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
this.vertexData = new Float32Array(MAX_VERTICES * 2);
this.texcoordData = new Float32Array(MAX_VERTICES * 2);
this.pointData = new Float32Array(MAX_POINTS * 4);
var indexData = new Uint16Array(MAX_INDICES);
i = 0, len = MAX_INDICES;
var fv = 0;
while (i < len)
{
indexData[i++] = fv;		// top left
indexData[i++] = fv + 1;	// top right
indexData[i++] = fv + 2;	// bottom right (first tri)
indexData[i++] = fv;		// top left
indexData[i++] = fv + 2;	// bottom right
indexData[i++] = fv + 3;	// bottom left
fv += 4;
}
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);
this.vertexPtr = 0;
this.pointPtr = 0;
this.matP = mat4.create();		// perspective matrix
this.matMV = mat4.create();		// model view matrix
this.lastMV = mat4.create();
var fsSource, vsSource;
/*
fsSource = [
"#ifdef GL_ES",
"precision {{precision}} float;",
"#endif",
"uniform sampler2D sampler;",
"varying float opacity;",
"void main(void) {",
"	gl_FragColor = texture2D(sampler, gl_PointCoord);",
"	gl_FragColor *= opacity;",
"}"
].join("\n");
fsSource = fsSource.replace("{{precision}}", isMobile ? "mediump" : "highp");
vsSource = [
"attribute vec4 aPos;",
"varying float opacity;",
"uniform mat4 matP;",
"uniform mat4 matMV;",
"void main(void) {",
"	gl_Position = matP * matMV * vec4(aPos.x, aPos.y, 0.0, 1.0);",
"	gl_PointSize = aPos.z;",
"	opacity = aPos.w;",
"}"
].join("\n");
this.fragmentShaderPoint = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(this.fragmentShaderPoint, fsSource);
gl.compileShader(this.fragmentShaderPoint);
;
this.vertexShaderPoint = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(this.vertexShaderPoint, vsSource);
gl.compileShader(this.vertexShaderPoint);
;
this.shaderProgramPoint = gl.createProgram();
gl.attachShader(this.shaderProgramPoint, this.fragmentShaderPoint);
gl.attachShader(this.shaderProgramPoint, this.vertexShaderPoint);
gl.linkProgram(this.shaderProgramPoint);
gl.useProgram(this.shaderProgramPoint);
;
this.locAPosPoint = gl.getAttribLocation(this.shaderProgramPoint, "aPos");
this.locMatPPoint = gl.getUniformLocation(this.shaderProgramPoint, "matP");
this.locMatMVPoint = gl.getUniformLocation(this.shaderProgramPoint, "matMV");
this.locSamplerPoint = gl.getUniformLocation(this.shaderProgramPoint, "sampler");
*/
fsSource = [
"#ifdef GL_ES",
"precision {{precision}} float;",
"#endif",
"varying vec2 vTex;",
"uniform float opacity;",
"uniform sampler2D sampler;",
"void main(void) {",
"	gl_FragColor = texture2D(sampler, vTex);",
"	gl_FragColor *= opacity;",
"}"
].join("\n");
fsSource = fsSource.replace("{{precision}}", isMobile ? "mediump" : "highp");
vsSource = [
"attribute vec2 aPos;",
"attribute vec2 aTex;",
"varying vec2 vTex;",
"uniform mat4 matP;",
"uniform mat4 matMV;",
"void main(void) {",
"	gl_Position = matP * matMV * vec4(aPos.x, aPos.y, 0.0, 1.0);",
"	vTex = aTex;",
"}"
].join("\n");
this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(this.fragmentShader, fsSource);
gl.compileShader(this.fragmentShader);
;
this.vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(this.vertexShader, vsSource);
gl.compileShader(this.vertexShader);
;
this.shaderProgram = gl.createProgram();
gl.attachShader(this.shaderProgram, this.fragmentShader);
gl.attachShader(this.shaderProgram, this.vertexShader);
gl.linkProgram(this.shaderProgram);
;
gl.useProgram(this.shaderProgram);
this.locAPos = gl.getAttribLocation(this.shaderProgram, "aPos");
gl.enableVertexAttribArray(this.locAPos);
this.locATex = gl.getAttribLocation(this.shaderProgram, "aTex");
gl.enableVertexAttribArray(this.locATex);
this.locMatP = gl.getUniformLocation(this.shaderProgram, "matP");
this.locMatMV = gl.getUniformLocation(this.shaderProgram, "matMV");
this.locOpacity = gl.getUniformLocation(this.shaderProgram, "opacity");
this.locSampler = gl.getUniformLocation(this.shaderProgram, "sampler");
gl.uniform1f(this.locOpacity, 1);		
gl.uniform1i(this.locSampler, 0);
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, null);
this.batch = [];
this.batchPtr = 0;
this.hasQuadBatchTop = false;
this.hasPointBatchTop = false;
this.isQuadProgram = true;
this.currentRenderTexture = null;
this.currentRenderOpacity = 1;
this.fbo = gl.createFramebuffer();
this.renderToTex = null;
this.tmpVec3 = vec3.create([0, 0, 0]);
;
;
var pointsizes = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);
this.minPointSize = pointsizes[0];
this.maxPointSize = pointsizes[1];
;
cr.seal(this);
};
var GLWrapProto = cr.GLWrap.prototype;
GLWrapProto.switchQuadProgram = function ()
{
if (this.isQuadProgram)
return;
var gl = this.gl;
this.gl.useProgram(this.shaderProgram);
this.isQuadProgram = true;
gl.enableVertexAttribArray(this.locAPos);
gl.enableVertexAttribArray(this.locATex);
};
GLWrapProto.switchPointProgram = function ()
{
if (!this.isQuadProgram)
return;
var gl = this.gl;
this.gl.useProgram(this.shaderProgramPoint);
this.isQuadProgram = false;
gl.enableVertexAttribArray(this.locAPosPoint);
gl.disableVertexAttribArray(this.locATex);
};
GLWrapProto.project = function (x, y, out)
{
var viewport = [0, 0, this.width, this.height];
var mv = this.matMV;
var proj = this.matP;
var fTempo = [0, 0, 0, 0, 0, 0, 0, 0];
fTempo[0] = mv[0]*x+mv[4]*y+mv[12];
fTempo[1] = mv[1]*x+mv[5]*y+mv[13];
fTempo[2] = mv[2]*x+mv[6]*y+mv[14];
fTempo[3] = mv[3]*x+mv[7]*y+mv[15];
fTempo[4] = proj[0]*fTempo[0]+proj[4]*fTempo[1]+proj[8]*fTempo[2]+proj[12]*fTempo[3];
fTempo[5] = proj[1]*fTempo[0]+proj[5]*fTempo[1]+proj[9]*fTempo[2]+proj[13]*fTempo[3];
fTempo[6] = proj[2]*fTempo[0]+proj[6]*fTempo[1]+proj[10]*fTempo[2]+proj[14]*fTempo[3];
fTempo[7] = -fTempo[2];
if(fTempo[7]===0.0)	//The w value
return;
fTempo[7]=1.0/fTempo[7];
fTempo[4]*=fTempo[7];
fTempo[5]*=fTempo[7];
fTempo[6]*=fTempo[7];
out[0]=(fTempo[4]*0.5+0.5)*viewport[2]+viewport[0];
out[1]=(fTempo[5]*0.5+0.5)*viewport[3]+viewport[1];
};
GLWrapProto.setSize = function(w, h)
{
if (this.width === w && this.height === h)
return;
this.width = w;
this.height = h;
this.gl.viewport(0, 0, w, h);
mat4.perspective(45, w / h, 1, 1000, this.matP);
mat4.lookAt(this.cam, this.look, this.up, this.matMV);
var tl = [0, 0];
var br = [0, 0];
this.project(0, 0, tl);
this.project(1, 1, br);
this.worldScale[0] = 1 / (br[0] - tl[0]);
this.worldScale[1] = -1 / (br[1] - tl[1]);
this.gl.uniformMatrix4fv(this.locMatP, false, this.matP);
};
GLWrapProto.resetModelView = function ()
{
mat4.lookAt(this.cam, this.look, this.up, this.matMV);
mat4.scale(this.matMV, this.worldScale);
};
GLWrapProto.translate = function (x, y)
{
if (x === 0 && y === 0)
return;
this.tmpVec3[0] = x;// * this.worldScale[0];
this.tmpVec3[1] = y;// * this.worldScale[1];
this.tmpVec3[2] = 0;
mat4.translate(this.matMV, this.tmpVec3);
};
GLWrapProto.scale = function (x, y)
{
if (x === 1 && y === 1)
return;
this.tmpVec3[0] = x;
this.tmpVec3[1] = y;
this.tmpVec3[2] = 1;
mat4.scale(this.matMV, this.tmpVec3);
};
GLWrapProto.rotateZ = function (a)
{
if (a === 0)
return;
mat4.rotateZ(this.matMV, a);
};
GLWrapProto.updateModelView = function()
{
var anydiff = false;
for (var i = 0; i < 16; i++)
{
if (this.lastMV[i] !== this.matMV[i])
{
anydiff = true;
break;
}
}
if (!anydiff)
return;
var b = this.pushBatch();
b.type = BATCH_UPDATEMODELVIEW;
if (b.mat4param)
mat4.set(this.matMV, b.mat4param);
else
b.mat4param = mat4.create(this.matMV);
mat4.set(this.matMV, this.lastMV);
this.hasQuadBatchTop = false;
this.hasPointBatchTop = false;
};
cr.GLBatchJob = function (type_, glwrap_)
{
this.type = type_;
this.glwrap = glwrap_;
this.gl = glwrap_.gl;
this.opacityParam = 0;		// for setOpacity()
this.startIndex = 0;		// for quad()
this.indexCount = 0;		// "
this.texParam = null;		// for setTexture()
this.mat4param = null;		// for updateModelView()
cr.seal(this);
};
var GLBatchJobProto = cr.GLBatchJob.prototype;
GLBatchJobProto.doSetTexture = function ()
{
this.gl.bindTexture(this.gl.TEXTURE_2D, this.texParam);
this.glwrap.currentRenderTexture = this.texParam;
};
GLBatchJobProto.doSetOpacity = function ()
{
this.gl.uniform1f(this.glwrap.locOpacity, this.opacityParam);
this.glwrap.currentRenderOpacity = this.opacityParam;
};
GLBatchJobProto.doQuad = function ()
{
this.gl.drawElements(this.gl.TRIANGLES, this.indexCount, this.gl.UNSIGNED_SHORT, this.startIndex * 2);
};
GLBatchJobProto.doSetBlend = function ()
{
this.gl.blendFunc(this.startIndex, this.indexCount);
};
GLBatchJobProto.doUpdateModelView = function ()
{
this.gl.uniformMatrix4fv(this.glwrap.locMatMV, false, this.mat4param);
};
GLBatchJobProto.doRenderToTexture = function ()
{
var gl = this.gl;
var glwrap = this.glwrap;
if (this.texParam)
{
gl.bindFramebuffer(gl.FRAMEBUFFER, glwrap.fbo);
gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texParam, 0);
;
}
else
{
gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}
};
GLBatchJobProto.doClear = function ()
{
this.gl.clearColor(this.mat4param[0], this.mat4param[1], this.mat4param[2], this.mat4param[3]);
this.gl.clear(this.gl.COLOR_BUFFER_BIT);
};
GLBatchJobProto.doPoints = function ()
{
/*
var gl = this.gl;
var glwrap = this.glwrap;
glwrap.switchPointProgram();
gl.bindBuffer(gl.ARRAY_BUFFER, glwrap.pointBuffer);
gl.vertexAttribPointer(glwrap.locAPosPoint, 4, gl.FLOAT, false, 0, 0);
gl.drawArrays(gl.POINTS, this.startIndex, this.indexCount);
glwrap.switchQuadProgram();
gl.bindBuffer(gl.ARRAY_BUFFER, glwrap.vertexBuffers[glwrap.curBuffer]);
gl.vertexAttribPointer(glwrap.locAPos, 2, gl.FLOAT, false, 0, 0);
gl.bindBuffer(gl.ARRAY_BUFFER, glwrap.texcoordBuffers[glwrap.curBuffer]);
gl.vertexAttribPointer(glwrap.locATex, 2, gl.FLOAT, false, 0, 0);
*/
};
GLWrapProto.pushBatch = function ()
{
if (this.batchPtr === this.batch.length)
this.batch.push(new cr.GLBatchJob(BATCH_NULL, this));
return this.batch[this.batchPtr++];
};
GLWrapProto.endBatch = function ()
{
if (this.batchPtr === 0)
return;
var gl = this.gl;
/*
if (this.pointPtr > 0)
{
this.switchPointProgram();
gl.bindBuffer(gl.ARRAY_BUFFER, this.pointBuffer);
gl.vertexAttribPointer(this.locAPosPoint, 4, gl.FLOAT, false, 0, 0);
gl.bufferData(gl.ARRAY_BUFFER, this.pointData.subarray(0, this.pointPtr), gl.STREAM_DRAW);
this.switchQuadProgram();
}
*/
if (this.vertexPtr > 0)
{
gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffers[this.curBuffer]);
gl.vertexAttribPointer(this.locAPos, 2, gl.FLOAT, false, 0, 0);
gl.bufferData(gl.ARRAY_BUFFER, this.vertexData.subarray(0, this.vertexPtr), gl.STREAM_DRAW);
gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffers[this.curBuffer]);
gl.vertexAttribPointer(this.locATex, 2, gl.FLOAT, false, 0, 0);
gl.bufferData(gl.ARRAY_BUFFER, this.texcoordData.subarray(0, this.vertexPtr), gl.STREAM_DRAW);
}
var i, len, b;
for (i = 0, len = this.batchPtr; i < len; i++)
{
b = this.batch[i];
switch (b.type) {
case BATCH_QUAD:
b.doQuad();
break;
case BATCH_SETTEXTURE:
b.doSetTexture();
break;
case BATCH_SETOPACITY:
b.doSetOpacity();
break;
case BATCH_SETBLEND:
b.doSetBlend();
break;
case BATCH_UPDATEMODELVIEW:
b.doUpdateModelView();
break;
case BATCH_RENDERTOTEXTURE:
b.doRenderToTexture();
break;
case BATCH_CLEAR:
b.doClear();
break;
case BATCH_POINTS:
b.doPoints();
break;
}
}
this.batchPtr = 0;
this.vertexPtr = 0;
this.pointPtr = 0;
this.hasQuadBatchTop = false;
this.hasPointBatchTop = false;
this.curBuffer++;
if (this.curBuffer >= MULTI_BUFFERS)
this.curBuffer = 0;
};
GLWrapProto.setOpacity = function (op)
{
if (op === this.lastOpacity)
return;
var b = this.pushBatch();
b.type = BATCH_SETOPACITY;
b.opacityParam = op;
this.lastOpacity = op;
this.hasQuadBatchTop = false;
this.hasPointBatchTop = false;
};
GLWrapProto.setTexture = function (tex)
{
if (tex === this.lastTexture)
return;
var b = this.pushBatch();
b.type = BATCH_SETTEXTURE;
b.texParam = tex;
this.lastTexture = tex;
this.hasQuadBatchTop = false;
this.hasPointBatchTop = false;
};
GLWrapProto.setBlend = function (s, d)
{
if (s === this.lastSrcBlend && d === this.lastDestBlend)
return;
var b = this.pushBatch();
b.type = BATCH_SETBLEND;
b.startIndex = s;		// recycle params to save memory
b.indexCount = d;
this.lastSrcBlend = s;
this.lastDestBlend = d;
this.hasQuadBatchTop = false;
this.hasPointBatchTop = false;
};
GLWrapProto.setAlphaBlend = function ()
{
this.setBlend(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);
};
var LAST_VERTEX = MAX_VERTICES * 2 - 8;
GLWrapProto.quad = function(tlx, tly, trx, try_, brx, bry, blx, bly)
{
if (this.vertexPtr >= LAST_VERTEX)
this.endBatch();
var v = this.vertexPtr;			// vertex cursor
var vd = this.vertexData;		// vertex data array
var td = this.texcoordData;		// texture coord data array
if (this.hasQuadBatchTop)
{
this.batch[this.batchPtr - 1].indexCount += 6;
}
else
{
var b = this.pushBatch();
b.type = BATCH_QUAD;
b.startIndex = (v / 4) * 3;
b.indexCount = 6;
this.hasQuadBatchTop = true;
this.hasPointBatchTop = false;
}
vd[v] = tlx;
td[v++] = 0;
vd[v] = tly;
td[v++] = 0;
vd[v] = trx;
td[v++] = 1;
vd[v] = try_;
td[v++] = 0;
vd[v] = brx;
td[v++] = 1;
vd[v] = bry;
td[v++] = 1;
vd[v] = blx;
td[v++] = 0;
vd[v] = bly;
td[v++] = 1;
this.vertexPtr = v;
};
GLWrapProto.quadTex = function(tlx, tly, trx, try_, brx, bry, blx, bly, rcTex)
{
if (this.vertexPtr >= LAST_VERTEX)
this.endBatch();
var v = this.vertexPtr;			// vertex cursor
var vd = this.vertexData;		// vertex data array
var td = this.texcoordData;		// texture coord data array
if (this.hasQuadBatchTop)
{
this.batch[this.batchPtr - 1].indexCount += 6;
}
else
{
var b = this.pushBatch();
b.type = BATCH_QUAD;
b.startIndex = (v / 4) * 3;
b.indexCount = 6;
this.hasQuadBatchTop = true;
this.hasPointBatchTop = false;
}
vd[v] = tlx;
td[v++] = rcTex.left;
vd[v] = tly;
td[v++] = rcTex.top;
vd[v] = trx;
td[v++] = rcTex.right;
vd[v] = try_;
td[v++] = rcTex.top;
vd[v] = brx;
td[v++] = rcTex.right;
vd[v] = bry;
td[v++] = rcTex.bottom;
vd[v] = blx;
td[v++] = rcTex.left;
vd[v] = bly;
td[v++] = rcTex.bottom;
this.vertexPtr = v;
};
var LAST_POINT = MAX_POINTS - 4;
/*
GLWrapProto.point = function(x_, y_, size_, opacity_)
{
if (this.pointPtr >= LAST_POINT)
this.endBatch();
var p = this.pointPtr;			// point cursor
var pd = this.pointData;		// point data array
if (this.hasPointBatchTop)
{
this.batch[this.batchPtr - 1].indexCount++;
}
else
{
var b = this.pushBatch();
b.type = BATCH_POINTS;
b.startIndex = p;
b.indexCount = 1;
this.hasPointBatchTop = true;
this.hasQuadBatchTop = false;
}
pd[p++] = x_;
pd[p++] = y_;
pd[p++] = size_;
pd[p++] = opacity_;
this.pointPtr = p;
};
*/
GLWrapProto.clear = function (r, g, b_, a)
{
var b = this.pushBatch();
b.type = BATCH_CLEAR;
if (!b.mat4param)
b.mat4param = mat4.create();
b.mat4param[0] = r;
b.mat4param[1] = g;
b.mat4param[2] = b_;
b.mat4param[3] = a;
this.hasQuadBatchTop = false;
this.hasPointBatchTop = false;
};
GLWrapProto.present = function ()
{
this.endBatch();
this.gl.flush();
};
function nextHighestPowerOfTwo(x) {
--x;
for (var i = 1; i < 32; i <<= 1) {
x = x | x >> i;
}
return x + 1;
}
GLWrapProto.loadTexture = function (img, tiling, linearsampling)
{
var gl = this.gl;
var isPOT = (cr.isPOT(img.width) && cr.isPOT(img.height));
var webGL_texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, webGL_texture);
gl.pixelStorei(gl["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], true);
if (!isPOT && tiling)
{
var canvas = document.createElement("canvas");
canvas.width = nextHighestPowerOfTwo(img.width);
canvas.height = nextHighestPowerOfTwo(img.height);
var ctx = canvas.getContext("2d");
ctx.drawImage(img,
0, 0, img.width, img.height,
0, 0, canvas.width, canvas.height);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
}
else
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, tiling ? gl.REPEAT : gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, tiling ? gl.REPEAT : gl.CLAMP_TO_EDGE);
if (linearsampling)
{
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
if (isPOT)
{
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
gl.generateMipmap(gl.TEXTURE_2D);
}
else
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
}
else
{
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
}
gl.bindTexture(gl.TEXTURE_2D, null);
webGL_texture.c2width = img.width;
webGL_texture.c2height = img.height;
return webGL_texture;
};
GLWrapProto.createEmptyTexture = function (w, h)
{
var gl = this.gl;
var webGL_texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, webGL_texture);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(w * h * 4));
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.bindTexture(gl.TEXTURE_2D, null);
webGL_texture.c2width = w;
webGL_texture.c2height = h;
return webGL_texture;
};
GLWrapProto.deleteTexture = function (tex)
{
this.endBatch();
this.gl.bindTexture(this.gl.TEXTURE_2D, null);
this.lastTexture = null;
this.gl.deleteTexture(tex);
};
GLWrapProto.setRenderingToTexture = function (tex)
{
if (tex === this.renderToTex)
return;
var b = this.pushBatch();
b.type = BATCH_RENDERTOTEXTURE;
b.texParam = tex;
this.renderToTex = tex;
this.hasQuadBatchTop = false;
this.hasPointBatchTop = false;
};
}());
;
(function()
{
cr.createRuntime = function (canvasid)
{
return new cr.runtime(document.getElementById(canvasid));
};
cr.runtime = function (canvas)
{
if (!canvas || !canvas.getContext)
return;
if (canvas["c2runtime"])
return;		// already created, don't double-create
else
canvas["c2runtime"] = this;
this.isPhoneGap = (typeof window["device"] !== "undefined" && typeof window["device"]["phonegap"] !== "undefined");
this.isAppMobi = (typeof window["AppMobi"] !== "undefined");
this.isWebKitMode = false;		// using -webkit-canvas background
this.isAndroid = /android/i.test(navigator.userAgent);
this.isMobile = (this.isPhoneGap || this.isAppMobi || this.isAndroid);
if (!this.isMobile)
this.isMobile = /(iphone|ipod|ipad|blackberry|palm|symbian|nokia|windows\s+ce|windows\s+phone|iemobile)/i.test(navigator.userAgent);
if (!this.isMobile)
this.isMobile = !(/(windows|linux|os\s+[x9]|solaris|bsd)/i.test(navigator.userAgent));
this.canvas = canvas;
this.gl = null;
this.glwrap = null;
this.ctx = null;
this.width = canvas.width;
this.height = canvas.height;
this.redraw = true;
if (!Date.now) {
Date.now = function now() {
return +new Date();
};
}
this.plugins = [];
this.types = {};
this.types_by_index = [];
this.behaviors = [];
this.layouts = {};
this.layouts_by_index = [];
this.eventsheets = {};
this.eventsheets_by_index = [];
this.wait_for_textures = [];        // for blocking until textures loaded
this.triggers_to_postinit = [];
this.all_global_vars = [];
this.deathRow = new cr.ObjectSet();
this.dt = 0;                
this.dt1 = 0;
this.zeroDtCount = 0;
this.timescale = 1.0;
this.kahanTime = new cr.KahanAdder();
this.last_tick_time = 0;
this.measuring_dt = true;
this.fps = 0;
this.last_fps_time = 0;
this.tickcount = 0;
this.execcount = 0;
this.framecount = 0;        // for fps
this.objectcount = 0;
this.changelayout = null;
this.destroycallbacks = [];
this.event_stack = [];
this.event_stack_index = -1;
this.pushEventStack(null);
this.loop_stack = [];
this.loop_stack_index = -1;
this.next_uid = 0;
this.layout_first_tick = true;
this.family_count = 0;
this.objects_to_tick = new cr.ObjectSet();
this.registered_collisions = [];
this.temp_poly = new cr.CollisionPoly([]);
this.activeGroups = {};				// event group activation states, in form activeGroups["eventsheetname|groupname"] = true/false
this.running_layout = null;			// currently running layout
this.layer_canvas = null;			// for layers "render-to-texture"
this.layer_ctx = null;
this.layer_tex = null;
this.files_subfolder = "";			// path with project files
this.html5logo = new Image();
this.html5logo.src = "logo.png";	// only 1kb!
this.load();
try {
if (this.enableWebGL && !this.isMobile)
{
var attribs = { "depth": false, "antialias": !this.isMobile };
this.gl = (canvas.getContext("webgl", attribs) || canvas.getContext("experimental-webgl", attribs)
|| canvas.getContext("webkit-3d", attribs) || canvas.getContext("moz-webgl", attribs));
}
}
catch (e) {
}
if (this.gl)
{
;
this.overlay_canvas = document.createElement("canvas");
jQuery(this.overlay_canvas).appendTo("body");
this.overlay_canvas.oncontextmenu = function (e) { return false; };
this.overlay_canvas.onselectstart = function (e) { return false; };
this.overlay_canvas.width = canvas.width;
this.overlay_canvas.height = canvas.height;
var overlay_position = jQuery(this.canvas).offset();
overlay_position.position = "absolute";
jQuery(this.overlay_canvas).css(overlay_position);
this.overlay_ctx = this.overlay_canvas.getContext("2d");
this.glwrap = new cr.GLWrap(this.gl, this.isMobile);
this.glwrap.setSize(canvas.width, canvas.height);
this.ctx = null;
}
else
{
if (this.fullscreen_mode > 0 && typeof document.getCSSCanvasContext !== "undefined")
{
;
jQuery(this.canvas).remove();
this.canvas = document.getElementsByTagName("body")[0];
document.oncontextmenu = function (e) { return false; };
document.onselectstart = function (e) { return false; };
this.canvas.setAttribute("style", "background: -webkit-canvas(c2csscanvas)");
this.ctx = document.getCSSCanvasContext("2d", "c2csscanvas", this.width, this.height);
this.isWebKitMode = true;
window["c2runtime"] = this;
window.setTimeout(function () {
var body = document.getElementsByTagName("body")[0];
var n = document.createTextNode(" ");
body.appendChild(n);
body.removeChild(n);
}, 16);
}
else
{
;
this.ctx = canvas.getContext("2d");
}
this.overlay_canvas = null;
this.overlay_ctx = null;
}
this.tickFunc = (function (self) { return function () { self.tick(); }; })(this);
this.go();
this.extra = {};
cr.seal(this);
};
var runtimeProto = cr.runtime.prototype;
runtimeProto["setSize"] = function (w, h)
{
this.width = w;
this.height = h;
this.redraw = true;
if (this.overlay_canvas)
{
this.overlay_canvas.width = w;
this.overlay_canvas.height = h;
}
if (this.glwrap)
this.glwrap.setSize(w, h);
if (this.isWebKitMode)
this.ctx = document.getCSSCanvasContext("2d", "c2csscanvas", this.width, this.height);
};
runtimeProto.load = function ()
{
;
var pm = cr.getProjectModel();
this.name = pm[0];
this.first_layout = pm[1];
this.fullscreen_mode = pm[11];	// 0 = off, 1 = crop, 2 = scale
this.system = new cr.system_object(this);
var i, len, j, lenj, k, lenk, idstr, m, b, t, f;
var plugin, plugin_ctor;
for (i = 0, len = pm[2].length; i < len; i++)
{
m = pm[2][i];
;
cr.add_common_aces(m);
plugin = new m[0](this);
plugin.singleglobal = m[1];
plugin.is_world = m[2];
if (plugin.onCreate)
plugin.onCreate();  // opportunity to override default ACEs
cr.seal(plugin);
this.plugins.push(plugin);
}
pm = cr.getProjectModel();
for (i = 0, len = pm[3].length; i < len; i++)
{
m = pm[3][i];
plugin_ctor = m[1];
;
plugin = null;
for (j = 0, lenj = this.plugins.length; j < lenj; j++)
{
if (this.plugins[j] instanceof plugin_ctor)
{
plugin = this.plugins[j];
break;
}
}
;
;
var type_inst = new plugin.Type(plugin);
;
type_inst.name = m[0];
type_inst.is_family = m[2];
type_inst.vars_count = m[3];
if (type_inst.is_family)
{
type_inst.members = [];				// types in this family
type_inst.family_index = this.family_count++;
type_inst.families = null;
type_inst.family_var_map = null;
}
else
{
type_inst.members = null;
type_inst.family_index = -1;
type_inst.families = [];			// families this type belongs to
type_inst.family_var_map = null;	// assigned later, get it in before the seal()
}
if (m[4])
{
type_inst.texture_file = m[4][0];
type_inst.texture_filesize = m[4][1];
}
else
{
type_inst.texture_file = null;
type_inst.texture_filesize = 0;
}
if (m[5])
{
type_inst.animations = m[5];
}
else
{
type_inst.animations = null;
}
type_inst.index = i;                                // save index in to types array in type
type_inst.instances = [];                           // all instances of this type
type_inst.deadCache = [];							// destroyed instances to recycle next create
type_inst.solstack = [new cr.selection(type_inst)]; // initialise SOL stack with one empty SOL
type_inst.cur_sol = 0;
type_inst.default_instance = null;
type_inst.stale_iids = true;
type_inst.updateIIDs = cr.type_updateIIDs;
type_inst.getFirstPicked = cr.type_getFirstPicked;
type_inst.getPairedInstance = cr.type_getPairedInstance;
type_inst.getCurrentSol = cr.type_getCurrentSol;
type_inst.pushCleanSol = cr.type_pushCleanSol;
type_inst.pushCopySol = cr.type_pushCopySol;
type_inst.popSol = cr.type_popSol;
type_inst.getBehaviorByName = cr.type_getBehaviorByName;
type_inst.getBehaviorIndexByName = cr.type_getBehaviorIndexByName;
type_inst.extra = {};
type_inst.toString = function () { return this.name; };
type_inst.behaviors = [];
for (j = 0, lenj = m[6].length; j < lenj; j++)
{
b = m[6][j];
var behavior_ctor = b[1];
var behavior_plugin = null;
for (k = 0, lenk = this.behaviors.length; k < lenk; k++)
{
if (this.behaviors[k] instanceof behavior_ctor)
{
behavior_plugin = this.behaviors[k];
break;
}
}
if (!behavior_plugin)
{
behavior_plugin = new behavior_ctor(this);
behavior_plugin.my_instances = new cr.ObjectSet(); 	// instances of this behavior
if (behavior_plugin.onCreate)
behavior_plugin.onCreate();
cr.seal(behavior_plugin);
this.behaviors.push(behavior_plugin);
}
var behavior_type = new behavior_plugin.Type(behavior_plugin, type_inst);
behavior_type.name = b[0];
behavior_type.onCreate();
cr.seal(behavior_type);
type_inst.behaviors.push(behavior_type);
}
type_inst.global = m[7];
type_inst.onCreate();
cr.seal(type_inst);
if (type_inst.name)
this.types[type_inst.name] = type_inst;
this.types_by_index.push(type_inst);
if (plugin.singleglobal)
{
var instance = new plugin.Instance(type_inst);
instance.uid = this.next_uid;
this.next_uid++;
instance.iid = 0;
instance.get_iid = cr.inst_get_iid;
instance.toString = cr.inst_toString;
instance.properties = m[8];
instance.onCreate();
cr.seal(instance);
type_inst.instances.push(instance);
}
}
for (i = 0, len = pm[4].length; i < len; i++)
{
var familydata = pm[4][i];
var familytype = this.types_by_index[familydata[0]];
var familymember;
for (j = 1, lenj = familydata.length; j < lenj; j++)
{
familymember = this.types_by_index[familydata[j]];
familymember.families.push(familytype);
familytype.members.push(familymember);
}
}
if (this.family_count > 0)
{
for (i = 0, len = this.types_by_index.length; i < len; i++)
{
t = this.types_by_index[i];
if (t.is_family || !t.families.length)
continue;
t.family_var_map = new Array(this.family_count);
var sum = 0;
for (j = 0, lenj = t.families.length; j < lenj; j++)
{
f = t.families[j];
t.family_var_map[f.family_index] = sum;
sum += f.vars_count;
}
}
}
for (i = 0, len = pm[5].length; i < len; i++)
{
m = pm[5][i];
var layout = new cr.layout(this, m);
cr.seal(layout);
this.layouts[layout.name] = layout;
this.layouts_by_index.push(layout);
}
for (i = 0, len = pm[6].length; i < len; i++)
{
m = pm[6][i];
var sheet = new cr.eventsheet(this, m);
cr.seal(sheet);
this.eventsheets[sheet.name] = sheet;
this.eventsheets_by_index.push(sheet);
}
for (i = 0, len = this.eventsheets_by_index.length; i < len; i++)
this.eventsheets_by_index[i].postInit();
for (i = 0, len = this.triggers_to_postinit.length; i < len; i++)
this.triggers_to_postinit[i].postInit();
delete this.triggers_to_postinit;
this.files_subfolder = pm[7];
this.pixel_rounding = pm[8];
this.original_width = pm[9];
this.original_height = pm[10];
this.aspect_scale = 1.0;
this.enableWebGL = pm[12];
this.linearSampling = pm[13];
this.clearBackground = pm[14];
this.versionstr = pm[15];
this.start_time = Date.now();
};
runtimeProto.areAllTexturesLoaded = function ()
{
var totalsize = 0;
var completedsize = 0;
var ret = true;
var i, len;
for (i = 0, len = this.wait_for_textures.length; i < len; i++)
{
var filesize = this.wait_for_textures[i].cr_filesize;
if (!filesize || filesize <= 0)
filesize = 50000;
totalsize += filesize;
if (this.wait_for_textures[i].complete)
completedsize += filesize;
else
ret = false;    // not all textures loaded
}
if (totalsize == 0)
this.progress = 0;
else
this.progress = (completedsize / totalsize);
return ret;
};
runtimeProto.go = function ()
{
if (!this.ctx && !this.glwrap)
return;
var ctx = this.ctx || this.overlay_ctx;
this.progress = 0;
this.last_progress = -1;
if (this.areAllTexturesLoaded())
this.go_textures_done();
else
{
var ms_elapsed = Date.now() - this.start_time;
if ((ms_elapsed >= 500 && this.html5logo.complete) && this.last_progress != this.progress)
{
ctx.clearRect(0, 0, this.width, this.height);
var mx = this.width / 2;
var my = this.height / 2;
var hlw = this.html5logo.width / 2;
var hlh = this.html5logo.height / 2;
ctx.drawImage(this.html5logo, Math.floor(mx - hlw), Math.floor(my - hlh));
my += hlh + 12;
mx -= hlw;
mx = Math.floor(mx) + 0.5;
my = Math.floor(my) + 0.5;
ctx.fillStyle = "DodgerBlue";
ctx.fillRect(mx, my, Math.floor(this.html5logo.width * this.progress), 6);
ctx.strokeStyle = "black";
ctx.strokeRect(mx, my, this.html5logo.width, 6);
ctx.strokeStyle = "white";
ctx.strokeRect(mx - 1, my - 1, this.html5logo.width + 2, 8);
this.last_progress = this.progress;
}
setTimeout((function (self) { return function () { self.go(); }; })(this), 100);
}
};
runtimeProto.go_textures_done = function ()
{
this.start_time = Date.now();
this.last_fps_time = this.start_time;       // for counting framerate
var i, len;
for (i = 0, len = this.layouts_by_index.length; i < len; i++)
{
this.layouts_by_index[i].createGlobalNonWorlds();
}
if (this.first_layout)
this.layouts[this.first_layout].startRunning();
else
this.layouts_by_index[0].startRunning();
;
this.tick();
};
var raf = window.requestAnimationFrame ||
window.mozRequestAnimationFrame    ||
window.webkitRequestAnimationFrame ||
window.msRequestAnimationFrame     ||
window.oRequestAnimationFrame;
runtimeProto.tick = function ()
{
;
if (this.overlay_canvas)
{
var overlay_position = jQuery(this.canvas).offset();
overlay_position.position = "absolute";
jQuery(this.overlay_canvas).css(overlay_position);
}
this.logic();
if (this.redraw && !document.hidden)
{
if (this.glwrap)
this.drawGL();
else
this.draw();
this.redraw = false;
}
this.tickcount++;
this.execcount++;
this.framecount++;
if (raf)
raf(this.tickFunc, this.canvas);
else
setTimeout(this.tickFunc, 16);
};
runtimeProto.logic = function ()
{
var i, leni, j, lenj, k, lenk, type, binst;
var cur_time = Date.now();
if (cur_time - this.last_fps_time >= 1000)  // every 1 second
{
this.last_fps_time += 1000;
this.fps = this.framecount;
this.framecount = 0;
}
if (this.measuring_dt)
{
if (this.last_tick_time !== 0)
{
var ms_diff = cur_time - this.last_tick_time;
if (ms_diff === 0)
{
this.zeroDtCount++;
if (this.zeroDtCout >= 10)
this.measuring_dt = false;
this.dt1 = 1.0 / 60.0;            // 60fps assumed (0.01666...)
}
else
{
this.dt1 = ms_diff / 1000.0; // dt measured in seconds
if (this.dt1 > 0.5 || document.hidden)
this.dt1 = 0;
else if (this.dt1 > 0.1)
this.dt1 = 0.1;
}
}
this.last_tick_time = cur_time;
}
this.dt = this.dt1 * this.timescale;
this.kahanTime.add(this.dt);
if (this.fullscreen_mode === 2 /* scale */)
{
var orig_aspect = this.original_width / this.original_height;
var cur_aspect = this.width / this.height;
if (cur_aspect > orig_aspect)
this.aspect_scale = this.height / this.original_height;
else
{
this.aspect_scale = this.width / this.original_width;
}
if (this.running_layout)
{
this.running_layout.scrollToX(this.running_layout.scrollX);
this.running_layout.scrollToY(this.running_layout.scrollY);
}
}
this.ClearDeathRow();
this.system.runWaits();
for (i = 0, leni = this.types_by_index.length; i < leni; i++)
{
type = this.types_by_index[i];
if (!type.behaviors.length)
continue;	// type doesn't have any behaviors
for (j = 0, lenj = type.instances.length; j < lenj; j++)
{
var inst = type.instances[j];
for (k = 0, lenk = inst.behavior_insts.length; k < lenk; k++)
{
inst.behavior_insts[k].tick();
}
}
}
var tickarr = this.objects_to_tick.valuesRef();
for (i = 0, leni = tickarr.length; i < leni; i++)
tickarr[i].tick();
if (this.changelayout)
{
;
this.running_layout.stopRunning();
this.changelayout.startRunning();
for (i = 0, leni = this.types_by_index.length; i < leni; i++)
{
type = this.types_by_index[i];
if (!type.global && !type.plugin.singleglobal)
continue;
for (j = 0, lenj = type.instances.length; j < lenj; j++)
{
var inst = type.instances[j];
if (inst.onLayoutChange)
inst.onLayoutChange();
}
}
this.changelayout = null;
this.redraw = true;
this.layout_first_tick = true;
this.ClearDeathRow();
}
for (i = 0, leni = this.eventsheets_by_index.length; i < leni; i++)
this.eventsheets_by_index[i].hasRun = false;
if (this.running_layout.event_sheet)
this.running_layout.event_sheet.run();
this.registered_collisions.length = 0;
this.layout_first_tick = false;
for (i = 0, leni = this.types_by_index.length; i < leni; i++)
{
type = this.types_by_index[i];
if (!type.behaviors.length)
continue;	// type doesn't have any behaviors
for (j = 0, lenj = type.instances.length; j < lenj; j++)
{
var inst = type.instances[j];
for (k = 0, lenk = inst.behavior_insts.length; k < lenk; k++)
{
binst = inst.behavior_insts[k];
if (binst.tick2)
binst.tick2();
}
}
}
};
runtimeProto.tickMe = function (inst)
{
this.objects_to_tick.add(inst);
};
runtimeProto.untickMe = function (inst)
{
this.objects_to_tick.remove(inst);
};
runtimeProto.getDt = function (inst)
{
if (!inst || inst.my_timescale === -1.0)
return this.dt;
return this.dt1 * inst.my_timescale;
};
runtimeProto.draw = function ()
{
this.running_layout.draw(this.ctx);
};
runtimeProto.drawGL = function ()
{
this.overlay_ctx.clearRect(0, 0, this.width, this.height);	
this.running_layout.drawGL(this.glwrap);
};
runtimeProto.addDestroyCallback = function (f)
{
if (f)
this.destroycallbacks.push(f);
};
runtimeProto.removeDestroyCallback = function (f)
{
cr.arrayFindRemove(this.destroycallbacks, f);
};
runtimeProto.DestroyInstance = function (inst)
{
this.deathRow.add(inst);
};
runtimeProto.ClearDeathRow = function ()
{
var inst, index, type, instances, binst;
var i, j, leni, lenj;
var w;
var arr = this.deathRow.valuesRef();	// get array of items from set
for (i = 0, leni = arr.length; i < leni; i++)
{
inst = arr[i];
type = inst.type;
instances = type.instances;
for (j = 0, lenj = this.destroycallbacks.length; j < lenj; j++)
this.destroycallbacks[j](inst);
cr.arrayFindRemove(instances, inst);
if (inst.layer)
{
cr.arrayRemove(inst.layer.instances, inst.get_zindex());
inst.layer.zindices_stale = true;
}
for (j = 0, lenj = type.families.length; j < lenj; j++)
cr.arrayFindRemove(type.families[j].instances, inst);
if (inst.behavior_insts)
{
for (j = 0, lenj = inst.behavior_insts.length; j < lenj; j++)
{
binst = inst.behavior_insts[j];
if (binst.onDestroy)
binst.onDestroy();
binst.behavior.my_instances.remove(inst);
}
}
this.objects_to_tick.remove(inst);
for (j = 0, lenj = this.system.waits.length; j < lenj; j++)
{
w = this.system.waits[j];
if (!w.sols.hasOwnProperty(type.index))
continue;
cr.arrayFindRemove(w.sols[type.index], inst);
}
if (inst.onDestroy)
inst.onDestroy();
this.objectcount--;
if (type.deadCache.length < 32)
type.deadCache.push(inst);
}
if (!this.deathRow.isEmpty())
this.redraw = true;
this.deathRow.clear();
};
runtimeProto.createInstance = function (type, layer, sx, sy)
{
if (type.is_family)
{
var i = Math.floor(Math.random() * type.members.length);
return this.createInstance(type.members[i], layer, sx, sy);
}
return this.createInstanceFromInit(type.default_instance, layer, false, sx, sy);
};
runtimeProto.createInstanceFromInit = function (initial_inst, layer, is_startup_instance, sx, sy)
{
var i, len, j, lenj, p;
;
var type = this.types_by_index[initial_inst[1]];
;
;
var is_world = type.plugin.is_world;
;
if (!is_world)
layer = null;
var inst;
var recycled_inst = false;
if (type.deadCache.length)
{
inst = type.deadCache.pop();
recycled_inst = true;
type.plugin.Instance.call(inst, type);
}
else
inst = new type.plugin.Instance(type);
inst.uid = this.next_uid;
this.next_uid++;
inst.iid = 0;
inst.get_iid = cr.inst_get_iid;
type.stale_iids = true;
var initial_vars = initial_inst[2];
if (recycled_inst)
{
for (i = 0, len = initial_vars.length; i < len; i++)
inst.instance_vars[i] = initial_vars[i];
cr.wipe(inst.extra);
}
else
{
inst.instance_vars = initial_vars.slice(0);
inst.extra = {};
}
if (is_world)
{
var wm = initial_inst[0];
;
inst.x = cr.is_undefined(sx) ? wm[0] : sx;
inst.y = cr.is_undefined(sy) ? wm[1] : sy;
inst.z = wm[2];
inst.width = wm[3];
inst.height = wm[4];
inst.depth = wm[5];
inst.angle = wm[6];
inst.opacity = wm[7];
inst.hotspotX = wm[8];
inst.hotspotY = wm[9];
if (recycled_inst)
{
inst.bbox.set(0, 0, 0, 0);
inst.bquad.set_from_rect(inst.bbox);
inst.bbox_changed_callbacks.length = 0;
}
else
{
inst.bbox = new cr.rect(0, 0, 0, 0);
inst.bquad = new cr.quad();
inst.bbox_changed_callbacks = [];
inst.set_bbox_changed = cr.set_bbox_changed;
inst.add_bbox_changed_callback = cr.add_bbox_changed_callback;
inst.contains_pt = cr.inst_contains_pt;
inst.update_bbox = cr.update_bbox;
inst.get_zindex = cr.inst_get_zindex;
}
inst.bbox_changed = true;
inst.visible = true;
inst.my_timescale = -1.0;
inst.layer = layer;
inst.zindex = layer.instances.length;	// will be placed at top of current layer
this.redraw = true;
}
inst.toString = cr.inst_toString;
var initial_props, binst;
if (recycled_inst)
{
for (i = 0, len = type.behaviors.length; i < len; i++)
{
var btype = type.behaviors[i];
binst = inst.behavior_insts[i];
btype.behavior.Instance.call(binst, btype, inst);
initial_props = initial_inst[3][i];
for (j = 0, lenj = initial_props.length; j < lenj; j++)
binst.properties[j] = initial_props[j];
binst.onCreate();
btype.behavior.my_instances.add(inst);
}
}
else
{
inst.behavior_insts = [];
for (i = 0, len = type.behaviors.length; i < len; i++)
{
var btype = type.behaviors[i];
var binst = new btype.behavior.Instance(btype, inst);
binst.properties = initial_inst[3][i].slice(0);
binst.onCreate();
cr.seal(binst);
inst.behavior_insts.push(binst);
btype.behavior.my_instances.add(inst);
}
}
initial_props = initial_inst[4];
if (recycled_inst)
{
for (i = 0, len = initial_props.length; i < len; i++)
inst.properties[i] = initial_props[i];
}
else
inst.properties = initial_props.slice(0);
type.instances.push(inst);
if (layer)
{
;
layer.instances.push(inst);
}
for (i = 0, len = type.families.length; i < len; i++)
type.families[i].instances.push(inst);
this.objectcount++;
inst.onCreate();
if (!recycled_inst)
cr.seal(inst);
for (i = 0, len = inst.behavior_insts.length; i < len; i++)
{
if (inst.behavior_insts[i].postCreate)
inst.behavior_insts[i].postCreate();
}
return inst;
};
runtimeProto.getLayerByName = function (layer_name)
{
var i, len;
for (i = 0, len = this.running_layout.layers.length; i < len; i++)
{
var layer = this.running_layout.layers[i];
if (layer.name.toLowerCase() === layer_name.toLowerCase())
return layer;
}
return null;
};
runtimeProto.getLayerByNumber = function (index)
{
index = Math.floor(index);
if (index < 0)
index = 0;
if (index >= this.running_layout.layers.length)
index = this.running_layout.layers.length - 1;
return this.running_layout.layers[index];
};
runtimeProto.getLayer = function (l)
{
if (cr.is_number(l))
return this.getLayerByNumber(l);
else
return this.getLayerByName(l.toString());
};
cr.layout = function (runtime, m)
{
this.runtime = runtime;
this.event_sheet = null;
this.scrollX = (this.runtime.original_width / 2);
this.scrollY = (this.runtime.original_height / 2);
this.scale = 1.0;
this.angle = 0;
this.name = m[0];
this.width = m[1];
this.height = m[2];
this.unbounded_scrolling = m[3];
this.sheetname = m[4];
var lm = m[5];
var i, len;
this.layers = [];
for (i = 0, len = lm.length; i < len; i++)
{
var layer = new cr.layer(this, lm[i]);
layer.number = i;
cr.seal(layer);
this.layers.push(layer);
}
var im = m[6];
this.initial_nonworld = [];
for (i = 0, len = im.length; i < len; i++)
{
var inst = im[i];
var type = this.runtime.types_by_index[inst[1]];
;
if (!type.default_instance)
type.default_instance = inst;
this.initial_nonworld.push(inst);
}
};
var layoutProto = cr.layout.prototype;
layoutProto.hasOpaqueBottomLayer = function ()
{
var layer = this.layers[0];
return !layer.transparent && layer.opacity === 1.0 && !layer.forceOwnTexture;
};
layoutProto.startRunning = function ()
{
if (this.sheetname)
{
this.event_sheet = this.runtime.eventsheets[this.sheetname];
;
}
this.runtime.running_layout = this;
this.scrollX = (this.runtime.original_width / 2);
this.scrollY = (this.runtime.original_height / 2);
var i, k, len, lenk, type_instances, inst;
for (i = 0, len = this.runtime.types_by_index.length; i < len; i++)
{
type_instances = this.runtime.types_by_index[i].instances;
for (k = 0, lenk = type_instances.length; k < lenk; k++)
{
inst = type_instances[k];
if (inst.layer)
{
var num = inst.layer.number;
if (num >= this.layers.length)
num = this.layers.length - 1;
inst.layer = this.layers[num];
inst.layer.instances.push(inst);
inst.layer.zindices_stale = true;
}
}
}
var layer;
for (i = 0, len = this.layers.length; i < len; i++)
{
layer = this.layers[i];
layer.createInitialInstances();
layer.viewLeft = 0;
layer.viewRight = 0;
layer.viewTop = 0;
layer.viewBottom = 0;
}
for (i = 0, len = this.initial_nonworld.length; i < len; i++)
{
inst = this.runtime.createInstanceFromInit(this.initial_nonworld[i], null, true);
;
}
this.runtime.trigger(cr.system_object.prototype.cnds.OnLayoutStart, null);
};
layoutProto.createGlobalNonWorlds = function ()
{
var i, k, len, initial_inst, inst, type;
for (i = 0, k = 0, len = this.initial_nonworld.length; i < len; i++)
{
initial_inst = this.initial_nonworld[i];
type = this.runtime.types_by_index[initial_inst[1]];
if (type.global)
inst = this.runtime.createInstanceFromInit(initial_inst, null, true);
else
{			
this.initial_nonworld[k] = initial_inst;
k++;
}
}
this.initial_nonworld.length = k;
};
layoutProto.stopRunning = function ()
{
;
this.runtime.trigger(cr.system_object.prototype.cnds.OnLayoutEnd, null);
this.runtime.system.waits.length = 0;
var i, leni, j, lenj;
var layer_instances, inst, type;
for (i = 0, leni = this.layers.length; i < leni; i++)
{
layer_instances = this.layers[i].instances;
for (j = 0, lenj = layer_instances.length; j < lenj; j++)
{
inst = layer_instances[j];
if (!inst.type.global)
this.runtime.DestroyInstance(inst);
}
this.runtime.ClearDeathRow();
layer_instances.length = 0;
this.layers[i].zindices_stale = true;
}
for (i = 0, leni = this.runtime.types_by_index.length; i < leni; i++)
{
type = this.runtime.types_by_index[i];
if (type.global || type.plugin.is_world || type.plugin.singleglobal)
continue;
for (j = 0, lenj = type.instances.length; j < lenj; j++)
this.runtime.DestroyInstance(type.instances[j]);
this.runtime.ClearDeathRow();
}
};
layoutProto.draw = function (ctx)
{
if (this.runtime.clearBackground && !this.hasOpaqueBottomLayer())
ctx.clearRect(0, 0, this.runtime.width, this.runtime.height);
var i, len;
for (i = 0, len = this.layers.length; i < len; i++)
{
if (this.layers[i].visible)
this.layers[i].draw(ctx);
}
};
layoutProto.drawGL = function (glw)
{
if (this.runtime.clearBackground && !this.hasOpaqueBottomLayer())
glw.clear(0, 0, 0, 0);
var i, len;
for (i = 0, len = this.layers.length; i < len; i++)
{
if (this.layers[i].visible)
this.layers[i].drawGL(glw);
}
glw.present();
};
layoutProto.getMinLayerScale = function ()
{
var m = this.layers[0].getScale();
var i, len, l;
for (i = 1, len = this.layers.length; i < len; i++)
{
l = this.layers[i];
if (l.parallaxX === 0 && l.parallaxY === 0)
continue;
if (l.getScale() < m)
m = l.getScale();
}
return m;
};
layoutProto.scrollToX = function (x)
{
if (!this.unbounded_scrolling)
{
var widthBoundary = (this.runtime.width * (1 / this.getMinLayerScale()) / 2);
if (x > this.width - widthBoundary)
x = this.width - widthBoundary;
if (x < widthBoundary)
x = widthBoundary;
}
if (this.scrollX !== x)
{
this.scrollX = x;
this.runtime.redraw = true;
}
};
layoutProto.scrollToY = function (y)
{		
if (!this.unbounded_scrolling)
{
var heightBoundary = (this.runtime.height * (1 / this.getMinLayerScale()) / 2);
if (y > this.height - heightBoundary)
y = this.height - heightBoundary;
if (y < heightBoundary)
y = heightBoundary;
}
if (this.scrollY !== y)
{
this.scrollY = y;
this.runtime.redraw = true;
}
};
cr.layer = function (layout, m)
{
this.layout = layout;
this.runtime = layout.runtime;
this.instances = [];        // running instances
this.scale = 1.0;
this.angle = 0;
this.disableAngle = false;
this.tmprect = new cr.rect(0, 0, 0, 0);
this.tmpquad = new cr.quad();
this.viewLeft = 0;
this.viewRight = 0;
this.viewTop = 0;
this.viewBottom = 0;
this.zindices_stale = false;
this.name = m[0];
this.index = m[1];
this.visible = m[2];		// initially visible
this.background_color = m[3];
this.transparent = m[4];
this.parallaxX = m[5];
this.parallaxY = m[6];
this.opacity = m[7];
this.forceOwnTexture = m[8];
this.zoomRate = m[9];
var im = m[10];
var i, len;
this.initial_instances = [];
for (i = 0, len = im.length; i < len; i++)
{
var inst = im[i];
var type = this.runtime.types_by_index[inst[1]];
;
if (!type.default_instance)
type.default_instance = inst;
this.initial_instances.push(inst);
}		
};
var layerProto = cr.layer.prototype;
layerProto.createInitialInstances = function ()
{
var i, k, len, inst;
for (i = 0, k = 0, len = this.initial_instances.length; i < len; i++)
{
inst = this.runtime.createInstanceFromInit(this.initial_instances[i], this, true);
if (!inst.type.global)
{
this.initial_instances[k] = this.initial_instances[i];
k++;
}
}
this.initial_instances.length = k;
};
layerProto.updateZIndices = function ()
{
if (!this.zindices_stale)
return;
var i, len;
for (i = 0, len = this.instances.length; i < len; i++)
{
;
;
this.instances[i].zindex = i;
}
this.zindices_stale = false;
};
layerProto.getScale = function ()
{
return ((this.scale * this.layout.scale * this.runtime.aspect_scale) - 1) * this.zoomRate + 1;
};
layerProto.getAngle = function ()
{
if (this.disableAngle)
return 0;
return cr.clamp_angle(this.layout.angle + this.angle);
};
layerProto.draw = function (ctx)
{
var render_offscreen = (this.forceOwnTexture || this.opacity !== 1.0);
var layer_canvas = this.runtime.canvas;
var layer_ctx = ctx;
if (render_offscreen)
{
if (!this.runtime.layer_canvas)
{
this.runtime.layer_canvas = document.createElement("canvas");
;
layer_canvas = this.runtime.layer_canvas;
layer_canvas.width = this.runtime.width;
layer_canvas.height = this.runtime.height;
this.runtime.layer_ctx = layer_canvas.getContext("2d");
;
}
layer_canvas = this.runtime.layer_canvas;
layer_ctx = this.runtime.layer_ctx;
if (layer_canvas.width !== this.runtime.width)
layer_canvas.width = this.runtime.width;
if (layer_canvas.height !== this.runtime.height)
layer_canvas.height = this.runtime.height;
if (this.transparent)
layer_ctx.clearRect(0, 0, this.runtime.width, this.runtime.height);
}
if (!this.transparent)
{
layer_ctx.fillStyle = "rgb(" + this.background_color[0] + "," + this.background_color[1] + "," + this.background_color[2] + ")";
layer_ctx.fillRect(0, 0, this.runtime.width, this.runtime.height);
}
layer_ctx.save();
this.disableAngle = true;
var px = this.canvasToLayer(0, 0, true);
var py = this.canvasToLayer(0, 0, false);
this.disableAngle = false;
if (this.runtime.pixel_rounding)
{
px = Math.round(px);
py = Math.round(py);
}
this.rotateViewport(px, py, layer_ctx);
var myscale = this.getScale();
layer_ctx.scale(myscale, myscale);
layer_ctx.translate(-px, -py);
var i, len, inst, bbox;
for (i = 0, len = this.instances.length; i < len; i++)
{
inst = this.instances[i];
if (!inst.visible || inst.width === 0 || inst.height === 0)
continue;
inst.update_bbox();
bbox = inst.bbox;
if (bbox.right < this.viewLeft || bbox.bottom < this.viewTop || bbox.left > this.viewRight || bbox.top > this.viewBottom)
continue;
inst.draw(layer_ctx);
}
layer_ctx.restore();
if (render_offscreen)
{
ctx.globalAlpha = this.opacity;
ctx.drawImage(layer_canvas, 0, 0);
ctx.globalAlpha = 1.0;
}
};
layerProto.rotateViewport = function (px, py, ctx)
{
var myscale = this.getScale();
this.viewLeft = px;
this.viewTop = py;
this.viewRight = px + (this.runtime.width * (1 / myscale));
this.viewBottom = py + (this.runtime.height * (1 / myscale));
var myAngle = this.getAngle();
if (myAngle !== 0)
{
ctx.translate(this.runtime.width / 2, this.runtime.height / 2);
ctx.rotate(-myAngle);
ctx.translate(this.runtime.width / -2, this.runtime.height / -2);
this.tmprect.set(this.viewLeft, this.viewTop, this.viewRight, this.viewBottom);
this.tmprect.offset((this.viewLeft + this.viewRight) / -2, (this.viewTop + this.viewBottom) / -2);
this.tmpquad.set_from_rotated_rect(this.tmprect, myAngle);
this.tmpquad.bounding_box(this.tmprect);
this.tmprect.offset((this.viewLeft + this.viewRight) / 2, (this.viewTop + this.viewBottom) / 2);
this.viewLeft = this.tmprect.left;
this.viewTop = this.tmprect.top;
this.viewRight = this.tmprect.right;
this.viewBottom = this.tmprect.bottom;
}
}
layerProto.drawGL = function (glw)
{
var overlay_ctx = this.runtime.overlay_ctx;
var render_offscreen = (this.forceOwnTexture || this.opacity !== 1.0);
if (render_offscreen)
{
if (!this.runtime.layer_tex)
{
this.runtime.layer_tex = glw.createEmptyTexture(this.runtime.width, this.runtime.height);
}
if (this.runtime.layer_tex.c2width !== this.runtime.width || this.runtime.layer_tex.c2height !== this.runtime.height)
{
glw.deleteTexture(this.runtime.layer_tex);
this.runtime.layer_tex = glw.createEmptyTexture(this.runtime.width, this.runtime.height);
}
glw.setRenderingToTexture(this.runtime.layer_tex);
if (this.transparent)
glw.clear(0, 0, 0, 0);
}
if (!this.transparent)
{
glw.clear(this.background_color[0] / 255, this.background_color[1] / 255, this.background_color[2] / 255, 1);
}
overlay_ctx.save();
this.disableAngle = true;
var px = this.canvasToLayer(0, 0, true);
var py = this.canvasToLayer(0, 0, false);
this.disableAngle = false;
if (this.runtime.pixel_rounding)
{
px = Math.round(px);
py = Math.round(py);
}
this.rotateViewport(px, py, overlay_ctx);
var myscale = this.getScale();
overlay_ctx.scale(myscale, myscale);
overlay_ctx.translate(-px, -py);
glw.resetModelView();
glw.scale(myscale, myscale);
glw.rotateZ(-this.getAngle());
glw.translate((this.viewLeft + this.viewRight) / -2, (this.viewTop + this.viewBottom) / -2);
glw.updateModelView();
var i, len, inst, bbox;
for (i = 0, len = this.instances.length; i < len; i++)
{
inst = this.instances[i];
if (!inst.visible || inst.width === 0 || inst.height === 0)
continue;
inst.update_bbox();
bbox = inst.bbox;
if (bbox.right < this.viewLeft || bbox.bottom < this.viewTop || bbox.left > this.viewRight || bbox.top > this.viewBottom)
continue;
inst.drawGL(glw);
}
overlay_ctx.restore();
if (render_offscreen)
{
glw.setRenderingToTexture(null);
glw.setOpacity(this.opacity);
glw.setTexture(this.runtime.layer_tex);
glw.setAlphaBlend();
glw.resetModelView();
glw.updateModelView();
var halfw = this.runtime.width / 2;
var halfh = this.runtime.height / 2;
glw.quad(-halfw, halfh, halfw, halfh, halfw, -halfh, -halfw, -halfh);
glw.setTexture(null);
}
};
layerProto.canvasToLayer = function (ptx, pty, getx)
{
var ox = (this.runtime.width / 2);
var oy = (this.runtime.height / 2);
var x = ((this.layout.scrollX - ox) * this.parallaxX) + ox;
var y = ((this.layout.scrollY - oy) * this.parallaxY) + oy;
var invScale = 1 / this.getScale();
x -= (this.runtime.width * invScale) / 2;
y -= (this.runtime.height * invScale) / 2;
x += ptx * invScale;
y += pty * invScale;
var a = this.getAngle();
if (a !== 0)
{
x -= this.layout.scrollX;
y -= this.layout.scrollY;
var cosa = Math.cos(a);
var sina = Math.sin(a);
var x_temp = (x * cosa) - (y * sina);
y = (y * cosa) + (x * sina);
x = x_temp;
x += this.layout.scrollX;
y += this.layout.scrollY;
}
return getx ? x : y;
};
layerProto.layerToCanvas = function (ptx, pty, getx)
{
var ox = (this.runtime.width / 2);
var oy = (this.runtime.height / 2);
var x = ((this.layout.scrollX - ox) * this.parallaxX) + ox;
var y = ((this.layout.scrollY - oy) * this.parallaxY) + oy;
var invScale = 1 / this.getScale();
x -= (this.runtime.width * invScale) / 2;
y -= (this.runtime.height * invScale) / 2;
x = (ptx - x) / invScale;
y = (pty - y) / invScale;
var a = this.getAngle();
if (a !== 0)
{
x -= ox;
y -= oy;
var cosa = Math.cos(-a);
var sina = Math.sin(-a);
var x_temp = (x * cosa) - (y * sina);
y = (y * cosa) + (x * sina);
x = x_temp;
x += ox;
y += oy;
}
return getx ? x : y;
};
}());
;
(function()
{
cr.eventsheet = function (runtime, m)
{
this.runtime = runtime;
this.triggers = {};
this.hasRun = false;
this.includes = new cr.ObjectSet(); // all event sheets included by this sheet, at first-level indirection only
this.name = m[0];
var em = m[1];		// events model
this.events = [];       // triggers won't make it to this array
var i, len;
for (i = 0, len = em.length; i < len; i++)
this.init_event(em[i], null, this.events);
};
var eventSheetProto = cr.eventsheet.prototype;
eventSheetProto.toString = function ()
{
return this.name;
};
eventSheetProto.init_event = function (m, parent, nontriggers)
{
switch (m[0]) {
case 0:	// event block
{
var block = new cr.eventblock(this, parent, m);
cr.seal(block);
if (block.is_trigger())
this.init_trigger(block);
else
nontriggers.push(block);
break;
}
case 1: // variable
{
var v = new cr.eventvariable(this, parent, m);
cr.seal(v);
nontriggers.push(v);
break;
}
case 2:	// include
{
var inc = new cr.eventinclude(this, parent, m);
cr.seal(inc);
nontriggers.push(inc);
break;
}
default:
;
}
};
eventSheetProto.postInit = function ()
{
var i, len;
for (i = 0, len = this.events.length; i < len; i++)
{
this.events[i].postInit();
}
};
eventSheetProto.run = function ()
{
this.hasRun = true;
var i, len;
for (i = 0, len = this.events.length; i < len; i++)
{
var ev = this.events[i];
ev.run();
this.runtime.clearSol(ev.solModifiers);
}
};
cr.selection = function (type)
{
this.type = type;
this.instances = [];        // subset of picked instances
this.select_all = true;
};
var solProto = cr.selection.prototype;
solProto.hasObjects = function ()
{
if (this.select_all)
return this.type.instances.length;
else
return this.instances.length;
};
solProto.getObjects = function ()
{
if (this.select_all)
return this.type.instances;
else
return this.instances;
};
solProto.pick = function (inst)
{
;
if (this.select_all)
{
this.select_all = false;
this.instances.length = 1;
this.instances[0] = inst;
}
else
{
if (jQuery.inArray(inst, this.instances) === -1)
this.instances.push(inst);
}
};
var runtimeProto = cr.runtime.prototype;
runtimeProto.clearSol = function (solModifiers)
{
var i, len;
for (i = 0, len = solModifiers.length; i < len; i++)
{
solModifiers[i].getCurrentSol().select_all = true;
}
};
runtimeProto.pushCleanSol = function (solModifiers)
{
var i, len;
for (i = 0, len = solModifiers.length; i < len; i++)
{
solModifiers[i].pushCleanSol();
}
};
runtimeProto.pushCopySol = function (solModifiers)
{
var i, len;
for (i = 0, len = solModifiers.length; i < len; i++)
{
solModifiers[i].pushCopySol();
}
};
runtimeProto.popSol = function (solModifiers)
{
var i, len;
for (i = 0, len = solModifiers.length; i < len; i++)
{
solModifiers[i].popSol();
}
};
cr.eventblock = function (sheet, parent, m)
{
this.sheet = sheet;
this.parent = parent;
this.runtime = sheet.runtime;
this.solModifiers = [];
this.solWriterAfterCnds = false;	// block does not change SOL after running its conditions
this.group = false;					// is group of events
this.toplevelgroup = false;			// is parented only by other groups or is top-level (i.e. not in a subevent)
;
this.conditions = [];
this.actions = [];
this.subevents = [];
if (m[1])
{
this.group_name = m[1][1].toLowerCase();
this.group = true;
if (m[1][0])
this.runtime.activeGroups[(/*this.sheet.name + "|" + */this.group_name).toLowerCase()] = true;
}
else
{
this.group_name = "";
this.group = false;
}	
var i, len;
var cm = m[2];
for (i = 0, len = cm.length; i < len; i++)
{
var cnd = new cr.condition(this, cm[i]);
cr.seal(cnd);
this.conditions.push(cnd);
this.addSolModifier(cnd.type);
}
var am = m[3];
for (i = 0, len = am.length; i < len; i++)
{
var act = new cr.action(this, am[i]);
cr.seal(act);
this.actions.push(act);
}
if (m.length === 5)
{
var em = m[4];
for (i = 0, len = em.length; i < len; i++)
this.sheet.init_event(em[i], this, this.subevents);
}
};
var eventblockProto = cr.eventblock.prototype;
eventblockProto.postInit = function ()
{
var p = this.parent;
if (this.group)
{
this.toplevelgroup = true;
while (p)
{
if (!p.group)
{
this.toplevelgroup = false;
break;
}
p = p.parent;
}
}
var i, len;
for (i = 0, len = this.conditions.length; i < len; i++)
this.conditions[i].postInit();
for (i = 0, len = this.actions.length; i < len; i++)
this.actions[i].postInit();
for (i = 0, len = this.subevents.length; i < len; i++)
this.subevents[i].postInit();
}
eventblockProto.addSolModifier = function (type)
{
if (!type)
return;
if (jQuery.inArray(type, this.solModifiers) === -1)
this.solModifiers.push(type);
};
eventblockProto.setSolWriterAfterCnds = function ()
{
this.solWriterAfterCnds = true;
if (this.parent)
this.parent.setSolWriterAfterCnds();
};
eventblockProto.is_trigger = function ()
{
if (!this.conditions.length)    // no conditions
return false;
else
return this.conditions[0].trigger;
};
eventblockProto.run = function ()
{
var i, len;
var evinfo = this.runtime.getCurrentEventStack();
evinfo.current_event = this;
for (evinfo.cndindex = 0, len = this.conditions.length; evinfo.cndindex < len; evinfo.cndindex++)
{
if (!this.conditions[evinfo.cndindex].run())    // condition failed
return false;                               // bail out
}
this.run_actions_and_subevents();
};
eventblockProto.run_actions_and_subevents = function ()
{
var evinfo = this.runtime.getCurrentEventStack();
var len;
for (evinfo.actindex = 0, len = this.actions.length; evinfo.actindex < len; evinfo.actindex++)
{
if (this.actions[evinfo.actindex].run())
return;
}
this.run_subevents();
};
eventblockProto.resume_actions_and_subevents = function ()
{
var evinfo = this.runtime.getCurrentEventStack();
var len;
for (len = this.actions.length; evinfo.actindex < len; evinfo.actindex++)
{
if (this.actions[evinfo.actindex].run())
return;
}
this.run_subevents();
};
eventblockProto.run_subevents = function ()
{
if (!this.subevents.length)
return;
var i, len, subev, pushpop;
var last = this.subevents.length - 1;
if (this.solWriterAfterCnds)
{
for (i = 0, len = this.subevents.length; i < len; i++)
{
subev = this.subevents[i];
pushpop = (!this.toplevelgroup || (!this.group && i < last));
if (pushpop)
this.runtime.pushCopySol(subev.solModifiers);
subev.run();
if (pushpop)
this.runtime.popSol(subev.solModifiers);
else
this.runtime.clearSol(subev.solModifiers);
}
}
else
{
for (i = 0, len = this.subevents.length; i < len; i++)
{
this.subevents[i].run();
}
}
};
eventblockProto.run_pretrigger = function ()
{
var evinfo = this.runtime.getCurrentEventStack();
evinfo.current_event = this;
var i, len;
for (evinfo.cndindex = 0, len = this.conditions.length; evinfo.cndindex < len; evinfo.cndindex++)
{
;
if (!this.conditions[evinfo.cndindex].run())  // condition failed
return false;               // bail out
}
return true;
};
eventblockProto.retrigger = function ()
{
this.runtime.execcount++;
var prevcndindex = this.runtime.getCurrentEventStack().cndindex;
var len;
var evinfo = this.runtime.pushEventStack(this);
for (evinfo.cndindex = prevcndindex + 1, len = this.conditions.length; evinfo.cndindex < len; evinfo.cndindex++)
{
if (!this.conditions[evinfo.cndindex].run())    // condition failed
{
this.runtime.popEventStack();               // moving up level of recursion
return false;                               // bail out
}
}
this.run_actions_and_subevents();
this.runtime.popEventStack();
};
cr.condition = function (block, m)
{
this.block = block;
this.sheet = block.sheet;
this.runtime = block.runtime;
this.parameters = [];
this.results = [];
this.extra = {};		// for plugins to stow away some custom info
this.func = m[1];
;
this.trigger = m[3];
this.looping = m[4];
this.inverted = m[5];
this.isstatic = m[6];
if (m[0] === -1)		// system object
{
this.type = null;
this.run = this.run_system;
this.behaviortype = null;
this.beh_index = -1;
}
else
{
this.type = this.runtime.types_by_index[m[0]];
;
if (this.isstatic)
this.run = this.run_static;
else
this.run = this.run_object;
if (m[2])
{
this.behaviortype = this.type.getBehaviorByName(m[2]);
;
this.beh_index = this.type.getBehaviorIndexByName(m[2]);
;
}
else
{
this.behaviortype = null;
this.beh_index = -1;
}
if (this.block.parent)
this.block.parent.setSolWriterAfterCnds();
}
if (m.length === 8)
{
var i, len;
var em = m[7];
for (i = 0, len = em.length; i < len; i++)
{
var param = new cr.parameter(this, em[i]);
cr.seal(param);
this.parameters.push(param);
}
this.results.length = em.length;
}
};
var conditionProto = cr.condition.prototype;
conditionProto.postInit = function ()
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.parameters[i].postInit();
};
conditionProto.run_system = function ()
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.results[i] = this.parameters[i].get();
return cr.xor(this.func.apply(this.runtime.system, this.results), this.inverted);
};
conditionProto.run_static = function ()
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.results[i] = this.parameters[i].get();
return this.func.apply(this.type, this.results);
};
conditionProto.run_object = function ()
{
var i, j, leni, lenj, ret, inst;
var sol = this.type.getCurrentSol();
if (sol.select_all) {
sol.instances.length = 0;       // clear contents
for (i = 0, leni = this.type.instances.length; i < leni; i++) {
inst = this.type.instances[i];
;
for (j = 0, lenj = this.parameters.length; j < lenj; j++)
this.results[j] = this.parameters[j].get(i);        // default SOL index is current object
if (this.beh_index > -1)
ret = this.func.apply(inst.behavior_insts[this.beh_index], this.results);
else
ret = this.func.apply(inst, this.results);
if (cr.xor(ret, this.inverted))
sol.instances.push(inst);
}
sol.select_all = false;
}
else {
var k = 0;
for (i = 0, leni = sol.instances.length; i < leni; i++) {
inst = sol.instances[i];
;
for (j = 0, lenj = this.parameters.length; j < lenj; j++)
this.results[j] = this.parameters[j].get(i);        // default SOL index is current object
if (this.beh_index > -1)
ret = this.func.apply(inst.behavior_insts[this.beh_index], this.results);
else
ret = this.func.apply(inst, this.results);
if (cr.xor(ret, this.inverted)) {
sol.instances[k] = inst;
k++;
}
}
sol.instances.length = k;
}
return sol.hasObjects();
};
cr.action = function (block, m)
{
this.block = block;
this.sheet = block.sheet;
this.runtime = block.runtime;
this.parameters = [];
this.results = [];
this.extra = {};		// for plugins to stow away some custom info
this.func = m[1];
;
if (m[0] === -1)	// system
{
this.type = null;
this.run = this.run_system;
this.behaviortype = null;
this.beh_index = -1;
}
else
{
this.type = this.runtime.types_by_index[m[0]];
;
this.run = this.run_object;
if (m[2])
{
this.behaviortype = this.type.getBehaviorByName(m[2]);
;
this.beh_index = this.type.getBehaviorIndexByName(m[2]);
;
}
else
{
this.behaviortype = null;
this.beh_index = -1;
}
}
if (m.length === 4)
{
var i, len;
var em = m[3];
for (i = 0, len = em.length; i < len; i++)
{
var param = new cr.parameter(this, em[i]);
cr.seal(param);
this.parameters.push(param);
}
this.results.length = em.length;
}
};
var actionProto = cr.action.prototype;
actionProto.postInit = function ()
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.parameters[i].postInit();
};
actionProto.run_system = function ()
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.results[i] = this.parameters[i].get();
return this.func.apply(this.runtime.system, this.results);
};
actionProto.run_object = function ()
{
var instances = this.type.getCurrentSol().getObjects();
var i, j, leni, lenj;
for (i = 0, leni = instances.length; i < leni; i++)
{
for (j = 0, lenj = this.parameters.length; j < lenj; j++)
this.results[j] = this.parameters[j].get(i);    // pass i to use as default SOL index
if (this.beh_index > -1)
this.func.apply(instances[i].behavior_insts[this.beh_index], this.results);
else
this.func.apply(instances[i], this.results);
}
return false;
};
cr.parameter = function (owner, m)
{
this.owner = owner;
this.block = owner.block;
this.sheet = owner.sheet;
this.runtime = owner.runtime;
this.type = m[0];
this.expression = null;
this.solindex = 0;
this.temp = null;
this.combosel = 0;
this.layout = null;
this.key = 0;
this.object = null;
this.index = 0;
this.varname = "";
this.eventvar = null;
this.fileinfo = null;
switch (m[0])
{
case 0:		// number
case 7:		// any
this.expression = new cr.expNode(this, m[1]);
this.solindex = 0;
this.get = this.get_exp;
this.temp = new cr.expvalue();
break;
case 1:		// string
this.expression = new cr.expNode(this, m[1]);
this.solindex = 0;
this.get = this.get_exp_str;
this.temp = new cr.expvalue();
break;
case 5:		// layer
this.expression = new cr.expNode(this, m[1]);
this.solindex = 0;
this.get = this.get_layer;
this.temp = new cr.expvalue();
break;
case 3:		// combo
case 8:		// cmp
this.combosel = m[1];
this.get = this.get_combosel;
break;
case 6:		// layout
this.layout = this.runtime.layouts[m[1]];
;
this.get = this.get_layout;
break;
case 9:		// keyb
this.key = m[1];
this.get = this.get_key;
break;
case 4:		// object
this.object = this.runtime.types_by_index[m[1]];
;
this.get = this.get_object;
this.block.addSolModifier(this.object);
if (this.owner instanceof cr.action)
this.block.setSolWriterAfterCnds();
else if (this.block.parent)
this.block.parent.setSolWriterAfterCnds();
break;
case 10:	// instvar
this.index = m[1];
if (owner.type.is_family)
this.get = this.get_familyvar;
else
this.get = this.get_instvar;
break;
case 11:	// eventvar
this.varname = m[1];
this.eventvar = null;
this.get = this.get_eventvar;
break;
case 2:		// audiofile
this.fileinfo = m[1];
this.get = this.get_audiofile;
break;
default:
;
}
};
var parameterProto = cr.parameter.prototype;
parameterProto.postInit = function ()
{
if (this.type === 11)	// eventvar
{
this.eventvar = this.runtime.getEventVariableByName(this.varname, this.block.parent);
;
}
if (this.expression)
this.expression.postInit();
};
parameterProto.get_exp = function (solindex)
{
this.solindex = solindex || 0;   // default SOL index to use
this.expression.get(this.temp)
return this.temp.data;      // return actual JS value, not expvalue
};
parameterProto.get_exp_str = function (solindex)
{
this.solindex = solindex || 0;   // default SOL index to use
this.expression.get(this.temp)
if (cr.is_string(this.temp.data))
return this.temp.data;
else
return "";
};
parameterProto.get_object = function ()
{
return this.object;
};
parameterProto.get_combosel = function ()
{
return this.combosel;
};
parameterProto.get_layer = function (solindex)
{
this.solindex = solindex || 0;   // default SOL index to use
this.expression.get(this.temp)
if (this.temp.is_number())
return this.runtime.getLayerByNumber(this.temp.data);
else
return this.runtime.getLayerByName(this.temp.data);
}
parameterProto.get_layout = function ()
{
return this.layout;
};
parameterProto.get_key = function ()
{
return this.key;
};
parameterProto.get_instvar = function ()
{
return this.index;
};
parameterProto.get_familyvar = function (solindex)
{
var familytype = this.owner.type;
var realtype = familytype.getCurrentSol().getObjects()[solindex].type;
return this.index + realtype.family_var_map[familytype.family_index];
};
parameterProto.get_eventvar = function ()
{
return this.eventvar;
};
parameterProto.get_audiofile = function ()
{
return this.fileinfo;
};
cr.eventvariable = function (sheet, parent, m)
{
this.sheet = sheet;
this.parent = parent;
this.runtime = sheet.runtime;
this.solModifiers = [];
if (!this.parent)		// global var
this.runtime.all_global_vars.push(this);
this.name = m[1];
this.vartype = m[2];
this.initial = m[3];
this.data = this.initial;
};
var eventvariableProto = cr.eventvariable.prototype;
eventvariableProto.postInit = function ()
{
};
eventvariableProto.run = function ()
{
if (this.parent)
this.data = this.initial;
};
cr.eventinclude = function (sheet, parent, m)
{
this.sheet = sheet;
this.parent = parent;
this.runtime = sheet.runtime;
this.solModifiers = [];
this.include_sheet = null;		// determined in postInit
this.include_sheet_name = m[1];
};
var eventincludeProto = cr.eventinclude.prototype;
eventincludeProto.postInit = function ()
{
this.include_sheet = this.runtime.eventsheets[this.include_sheet_name];
;
;
this.sheet.includes.add(this.include_sheet);
};
eventincludeProto.run = function ()
{
if (this.parent)
this.runtime.pushCleanSol(this.runtime.types_by_index);
if (!this.include_sheet.hasRun)
this.include_sheet.run();
if (this.parent)
this.runtime.popSol(this.runtime.types_by_index);
};
runtimeProto.testAndSelectCanvasPointOverlap = function (type, ptx, pty, inverted)
{
var sol = type.getCurrentSol();
var i, j, inst, len;
var lx, ly;
if (sol.select_all)
{
if (!inverted)
{
sol.select_all = false;
sol.instances.length = 0;   // clear contents
}
for (i = 0, len = type.instances.length; i < len; i++)
{
inst = type.instances[i];
inst.update_bbox();
lx = inst.layer.canvasToLayer(ptx, pty, true);
ly = inst.layer.canvasToLayer(ptx, pty, false);
if (inst.contains_pt(lx, ly))
{
if (inverted)
return false;
else
sol.instances.push(inst);
}
}
}
else
{
j = 0;
for (i = 0, len = sol.instances.length; i < len; i++)
{
inst = sol.instances[i];
inst.update_bbox();
lx = inst.layer.canvasToLayer(ptx, pty, true);
ly = inst.layer.canvasToLayer(ptx, pty, false);
if (inst.contains_pt(lx, ly))
{
if (inverted)
return false;
else
{
sol.instances[j] = sol.instances[i];
j++;
}
}
}
if (!inverted)
sol.instances.length = j;
}
if (inverted)
return true;		// did not find anything overlapping
else
return sol.hasObjects();
};
runtimeProto.testOverlap = function (a, b)
{
if (!a || !b)
return false;
if (a === b)
return false;
a.update_bbox();
b.update_bbox();
if (!a.bbox.intersects_rect(b.bbox))
return false;
if (!a.bquad.intersects_quad(b.bquad))
return false;
var haspolya = (a.collision_poly && !a.collision_poly.is_empty());
var haspolyb = (b.collision_poly && !b.collision_poly.is_empty());
if (!haspolya && !haspolyb)
return true;
var polya, polyb;
if (haspolya)
{
a.collision_poly.cache_poly(a.width, a.height, a.angle);
polya = a.collision_poly;
}
else
{
this.temp_poly.set_from_quad(a.bquad, a.x, a.y, a.width, a.height);
polya = this.temp_poly;
}
if (haspolyb)
{
b.collision_poly.cache_poly(b.width, b.height, b.angle);
polyb = b.collision_poly;
}
else
{
this.temp_poly.set_from_quad(b.bquad, b.x, b.y, b.width, b.height);
polyb = this.temp_poly;
}
return polya.intersects_poly(polyb, b.x - a.x, b.y - a.y);
};
runtimeProto.testOverlapSolid = function (inst)
{
var solid = null;
var i, len, s;
if (!cr.behaviors.solid)
return null;
for (i = 0, len = this.behaviors.length; i < len; i++)
{
if (this.behaviors[i] instanceof cr.behaviors.solid)
{
solid = this.behaviors[i];
break;
}
}
if (!solid)
return null;
var solids = solid.my_instances.valuesRef();
for (i = 0, len = solids.length; i < len; ++i)
{
s = solids[i];
if (!s.extra.solidEnabled)
continue;
if (this.testOverlap(inst, s))
return s;
}
return null;
};
var jumpthru_array_ret = [];
runtimeProto.testOverlapJumpThru = function (inst, all)
{
var jumpthru = null;
var i, len, s;
if (!cr.behaviors.jumpthru)
return null;
for (i = 0, len = this.behaviors.length; i < len; i++)
{
if (this.behaviors[i] instanceof cr.behaviors.jumpthru)
{
jumpthru = this.behaviors[i];
break;
}
}
if (!jumpthru)
return null;
var ret = null;
if (all)
{
ret = jumpthru_array_ret;
ret.length = 0;
}
var jumpthrus = jumpthru.my_instances.valuesRef();
for (i = 0, len = jumpthrus.length; i < len; ++i)
{
s = jumpthrus[i];
if (!s.extra.jumpthruEnabled)
continue;
if (this.testOverlap(inst, s))
{
if (all)
ret.push(s);
else
return s;
}
}
return ret;
};
runtimeProto.pushOutSolid = function (inst, xdir, ydir, dist, include_jumpthrus)
{
var push_dist = dist || 50;
var oldx = inst.x
var oldy = inst.y;
var i;
var last_overlapped = null;
for (i = 0; i < push_dist; i++)
{
inst.x = Math.floor(oldx + (xdir * i));
inst.y = Math.floor(oldy + (ydir * i));
inst.set_bbox_changed();
if (!this.testOverlap(inst, last_overlapped))
{
last_overlapped = this.testOverlapSolid(inst);
if (!last_overlapped)
{
if (include_jumpthrus)
last_overlapped = this.testOverlapJumpThru(inst);
if (!last_overlapped)
return true;
}
}
}
inst.x = oldx;
inst.y = oldy;
inst.set_bbox_changed();
return false;
};
runtimeProto.pushOutSolidNearest = function (inst, max_dist_)
{
var max_dist = (cr.is_undefined(max_dist_) ? 100 : max_dist_);
var dist = 0;
var oldx = inst.x
var oldy = inst.y;
var dir = 0;
var dx = 0, dy = 0;
var last_overlapped = null;
while (dist <= max_dist)
{
switch (dir) {
case 0:		dx = 0; dy = -1; dist++; break;
case 1:		dx = 1; dy = -1; break;
case 2:		dx = 1; dy = 0; break;
case 3:		dx = 1; dy = 1; break;
case 4:		dx = 0; dy = 1; break;
case 5:		dx = -1; dy = 1; break;
case 6:		dx = -1; dy = 0; break;
case 7:		dx = -1; dy = -1; break;
}
dir = (dir + 1) % 8;
inst.x = Math.floor(oldx + (dx * dist));
inst.y = Math.floor(oldy + (dy * dist));
inst.set_bbox_changed();
if (!this.testOverlap(inst, last_overlapped))
{
last_overlapped = this.testOverlapSolid(inst);
if (!last_overlapped)
return true;
}
}
inst.x = oldx;
inst.y = oldy;
inst.set_bbox_changed();
return false;
};
runtimeProto.registerCollision = function (a, b)
{
this.registered_collisions.push([a, b]);
};
runtimeProto.checkRegisteredCollision = function (a, b)
{
var i, len, x;
for (i = 0, len = this.registered_collisions.length; i < len; i++)
{
x = this.registered_collisions[i];
if ((x[0] == a && x[1] == b) || (x[0] == b && x[1] == a))
return true;
}
return false;
};
runtimeProto.calculateSolidBounceAngle = function(inst, startx, starty, obj)
{
var objx = inst.x;
var objy = inst.y;
var radius = Math.max(10, cr.distanceTo(startx, starty, objx, objy));
var startangle = cr.angleTo(startx, starty, objx, objy);
var firstsolid = obj || this.testOverlapSolid(inst);
if (!firstsolid)
return cr.clamp_angle(startangle + Math.PI);
var cursolid = firstsolid;
var i, curangle, anticlockwise_free_angle, clockwise_free_angle;
var increment = cr.to_radians(5);	// 5 degree increments
for (i = 1; i < 36; i++)
{
curangle = startangle - i * increment;
inst.x = startx + Math.cos(curangle) * radius;
inst.y = starty + Math.sin(curangle) * radius;
inst.set_bbox_changed();
if (!this.testOverlap(inst, cursolid))
{
cursolid = obj ? null : this.testOverlapSolid(inst);
if (!cursolid)
{
anticlockwise_free_angle = curangle;
break;
}
}
}
if (i === 36)
anticlockwise_free_angle = cr.clamp_angle(startangle + Math.PI);
var cursolid = firstsolid;
for (i = 1; i < 36; i++)
{
curangle = startangle + i * increment;
inst.x = startx + Math.cos(curangle) * radius;
inst.y = starty + Math.sin(curangle) * radius;
inst.set_bbox_changed();
if (!this.testOverlap(inst, cursolid))
{
cursolid = obj ? null : this.testOverlapSolid(inst);
if (!cursolid)
{
clockwise_free_angle = curangle;
break;
}
}
}
if (i === 36)
clockwise_free_angle = cr.clamp_angle(startangle + Math.PI);
inst.x = objx;
inst.y = objy;
inst.set_bbox_changed();
if (clockwise_free_angle === anticlockwise_free_angle)
return clockwise_free_angle;
var half_diff = cr.angleDiff(clockwise_free_angle, anticlockwise_free_angle) / 2;
var normal;
if (cr.angleClockwise(clockwise_free_angle, anticlockwise_free_angle))
{
normal = cr.clamp_angle(anticlockwise_free_angle + half_diff + Math.PI);
}
else
{
normal = cr.clamp_angle(clockwise_free_angle + half_diff);
}
;
var vx = Math.cos(startangle);
var vy = Math.sin(startangle);
var nx = Math.cos(normal);
var ny = Math.sin(normal);
var v_dot_n = vx * nx + vy * ny;
var rx = vx - 2 * v_dot_n * nx;
var ry = vy - 2 * v_dot_n * ny;
return cr.angleTo(0, 0, rx, ry);
};
eventSheetProto.init_trigger = function (trig)
{
;
this.runtime.triggers_to_postinit.push(trig);
var type_name;
if (trig.conditions[0].type)
type_name = trig.conditions[0].type.name;
else
type_name = "system";
if (!this.triggers[type_name])
this.triggers[type_name] = [];
var obj_entry = this.triggers[type_name];
var method = trig.conditions[0].func;
var i, len;
for (i = 0, len = obj_entry.length; i < len; i++)
{
if (obj_entry[i].method == method)
{
obj_entry[i].evs.push(trig);
return;
}
}
obj_entry.push({ method: method, evs: [trig]});
};
var triggerSheetStack = [];
var triggerSheetIndex = -1;
runtimeProto.trigger = function (method, inst)
{
;
if (!this.running_layout)
return false;
var sheet = this.running_layout.event_sheet;
if (!sheet)
return false;     // no event sheet active; nothing to trigger
triggerSheetIndex++;
if (triggerSheetIndex === triggerSheetStack.length)
triggerSheetStack.push(new cr.ObjectSet());
else
triggerSheetStack[triggerSheetIndex].clear();
var ret = this.triggerOnSheet(method, inst, sheet);
triggerSheetIndex--;
return ret;
};
runtimeProto.triggerOnSheet = function (method, inst, sheet)
{
var alreadyTriggeredSheets = triggerSheetStack[triggerSheetIndex];
if (alreadyTriggeredSheets.contains(sheet))
return false;
alreadyTriggeredSheets.add(sheet);
var includes = sheet.includes.valuesRef();
var ret = false;
var i, j, leni, lenj;
for (i = 0, leni = includes.length; i < leni; i++)
{
var r = this.triggerOnSheet(method, inst, includes[i]);
ret = ret || r;
}
var type_name;
if (!inst)
type_name = "system";
else
type_name = inst.type.name;
if (!sheet.triggers[type_name])
return ret;
var obj_entry = sheet.triggers[type_name];
var triggers_list = null;
for (i = 0, leni = obj_entry.length; i < leni; i++)
{
if (obj_entry[i].method == method)
{
triggers_list = obj_entry[i].evs;
break;
}
}
if (!triggers_list)
return ret;
for (i = 0, leni = triggers_list.length; i < leni; i++)
{
var trig = triggers_list[i];
this.pushCleanSol(trig.solModifiers);
this.pushEventStack(trig);
if (inst)
{
var sol = inst.type.getCurrentSol();
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = inst;
}
var ok_to_run = true;
if (trig.parent)
{
var temp_parents_arr = this.getCurrentEventStack().temp_parents_arr;
var cur_parent = trig.parent;
while (cur_parent)
{
temp_parents_arr.push(cur_parent);
cur_parent = cur_parent.parent;
}
temp_parents_arr.reverse();
for (j = 0, lenj = temp_parents_arr.length; j < lenj; j++)
this.pushCleanSol(temp_parents_arr[j].solModifiers);
for (j = 0, lenj = temp_parents_arr.length; j < lenj; j++)
{
if (!temp_parents_arr[j].run_pretrigger())   // parent event failed
{
ok_to_run = false;
break;
}
}
for (j = 0, lenj = temp_parents_arr.length; j < lenj; j++)
this.popSol(temp_parents_arr[j].solModifiers);
}
if (ok_to_run)
{
this.execcount++;
trig.run();
ret = true;     // something got triggered
}
this.popSol(trig.solModifiers);
this.popEventStack();
}
return ret;             // true if anything got triggered
};
cr.eventStackFrame = function ()
{
this.temp_parents_arr = [];
this.reset(null);
cr.seal(this);
};
var eventStackFrameProto = cr.eventStackFrame.prototype;
eventStackFrameProto.reset = function (cur_event)
{
this.current_event = cur_event;
this.cndindex = 0;
this.actindex = 0;
this.temp_parents_arr.length = 0;
};
eventStackFrameProto.isModifierAfterCnds = function ()
{
if (this.current_event.solWriterAfterCnds)
return true;
if (this.cndindex < this.current_event.conditions.length - 1)
return !!this.current_event.solModifiers.length;
return false;
};
runtimeProto.getCurrentCondition = function ()
{
var evinfo = this.getCurrentEventStack();
return evinfo.current_event.conditions[evinfo.cndindex];
};
runtimeProto.getCurrentAction = function ()
{
var evinfo = this.getCurrentEventStack();
return evinfo.current_event.actions[evinfo.actindex];
};
runtimeProto.pushEventStack = function (cur_event)
{
this.event_stack_index++;
if (this.event_stack_index >= this.event_stack.length)
this.event_stack.push(new cr.eventStackFrame());
var ret = this.getCurrentEventStack();
ret.reset(cur_event);
return ret;
};
runtimeProto.popEventStack = function ()
{
;
this.event_stack_index--;
};
runtimeProto.getCurrentEventStack = function ()
{
return this.event_stack[this.event_stack_index];
};
runtimeProto.pushLoopStack = function (name_)
{
this.loop_stack_index++;
if (this.loop_stack_index >= this.loop_stack.length)
{
this.loop_stack.push(cr.seal({ name: name_, index: 0, stopped: false }));
}
var ret = this.getCurrentLoop();
ret.name = name_;
ret.index = 0;
ret.stopped = false;
return ret;
};
runtimeProto.popLoopStack = function ()
{
;
this.loop_stack_index--;
};
runtimeProto.getCurrentLoop = function ()
{
return this.loop_stack[this.loop_stack_index];
};
runtimeProto.getEventVariableByName = function (name, scope)
{
var i, leni, j, lenj, sheet, e;
while (scope)
{
for (i = 0, leni = scope.subevents.length; i < leni; i++)
{
e = scope.subevents[i];
if (e instanceof cr.eventvariable && name.toLowerCase() === e.name.toLowerCase())
return e;
}
scope = scope.parent;
}
for (i = 0, leni = this.eventsheets_by_index.length; i < leni; i++)
{
sheet = this.eventsheets_by_index[i];
for (j = 0, lenj = sheet.events.length; j < lenj; j++)
{
e = sheet.events[j];
if (e instanceof cr.eventvariable && name.toLowerCase() === e.name.toLowerCase())
return e;
}
}
return null;
};
}());
(function()
{
cr.expNode = function (owner_, m)
{
this.owner = owner_;
this.runtime = owner_.runtime;
this.type = m[0];
;
this.get = [this.eval_int,
this.eval_float,
this.eval_string,
this.eval_unaryminus,
this.eval_add,
this.eval_subtract,
this.eval_multiply,
this.eval_divide,
this.eval_mod,
this.eval_power,
this.eval_and,
this.eval_or,
this.eval_equal,
this.eval_notequal,
this.eval_less,
this.eval_lessequal,
this.eval_greater,
this.eval_greaterequal,
this.eval_conditional,
this.eval_system_exp,
this.eval_object_behavior_exp,
this.eval_instvar_exp,
this.eval_object_behavior_exp,
this.eval_eventvar_exp][this.type];
var paramsModel = null;
this.temp = new cr.expvalue();
this.value = null;
this.first = null;
this.second = null;
this.third = null;
this.func = null;
this.results = null;
this.parameters = null;
this.object_type = null;
this.beh_index = -1;
this.instance_expr = null;
this.varindex = -1;
this.behavior_type = null;
this.varname = "";
this.eventvar = null;
this.return_string = false;
switch (this.type) {
case 0:		// int
case 1:		// float
case 2:		// string
this.value = m[1];
break;
case 3:		// unaryminus
this.first = new cr.expNode(owner_, m[1]);
break;
case 18:	// conditional
this.first = new cr.expNode(owner_, m[1]);
this.second = new cr.expNode(owner_, m[2]);
this.third = new cr.expNode(owner_, m[3]);
break;
case 19:	// system_exp
this.func = m[1];
;
this.results = [];
this.parameters = [];
if (m.length === 3)
{
paramsModel = m[2];
this.results.length = paramsModel.length + 1;	// must also fit 'ret'
}
else
this.results.length = 1;      // to fit 'ret'
break;
case 20:	// object_exp
this.object_type = this.runtime.types_by_index[m[1]];
;
this.beh_index = -1;
this.func = m[2];
this.return_string = m[3];
if (m[4])
this.instance_expr = new cr.expNode(owner_, m[4]);
else
this.instance_expr = null;
this.results = [];
this.parameters = [];
if (m.length === 6)
{
paramsModel = m[5];
this.results.length = paramsModel.length + 1;
}
else
this.results.length = 1;	// to fit 'ret'
break;
case 21:		// instvar_exp
this.object_type = this.runtime.types_by_index[m[1]];
;
this.return_string = m[2];
if (m[3])
this.instance_expr = new cr.expNode(owner_, m[3]);
else
this.instance_expr = null;
this.varindex = m[4];
break;
case 22:		// behavior_exp
this.object_type = this.runtime.types_by_index[m[1]];
;
this.behavior_type = this.object_type.getBehaviorByName(m[2]);
;
this.beh_index = this.object_type.getBehaviorIndexByName(m[2]);
this.func = m[3];
this.return_string = m[4];
if (m[5])
this.instance_expr = new cr.expNode(owner_, m[5]);
else
this.instance_expr = null;
this.results = [];
this.parameters = [];
if (m.length === 7)
{
paramsModel = m[6];
this.results.length = paramsModel.length + 1;
}
else
this.results.length = 1;	// to fit 'ret'
break;
case 23:		// eventvar_exp
this.varname = m[1];
this.eventvar = null;	// assigned in postInit
break;
}
if (this.type >= 4 && this.type <= 17)
{
this.first = new cr.expNode(owner_, m[1]);
this.second = new cr.expNode(owner_, m[2]);
}
if (paramsModel)
{
var i, len;
for (i = 0, len = paramsModel.length; i < len; i++)
this.parameters.push(new cr.expNode(owner_, paramsModel[i]));
}
cr.seal(this);
};
var expNodeProto = cr.expNode.prototype;
expNodeProto.postInit = function ()
{
if (this.type === 23)	// eventvar_exp
{
this.eventvar = this.owner.runtime.getEventVariableByName(this.varname, this.owner.block.parent);
;
}
if (this.first)
this.first.postInit();
if (this.second)
this.second.postInit();
if (this.third)
this.third.postInit();
if (this.instance_expr)
this.instance_expr.postInit();
if (this.parameters)
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.parameters[i].postInit();
}
};
expNodeProto.eval_system_exp = function (ret)
{
this.results[0] = ret;
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
{
this.parameters[i].get(this.temp);
this.results[i + 1] = this.temp.data;   // passing actual javascript value as argument instead of expvalue
}
this.func.apply(this.runtime.system, this.results);
};
expNodeProto.eval_object_behavior_exp = function (ret)
{
var sol = this.object_type.getCurrentSol();
var instances = sol.getObjects();
if (!instances.length) {
if (this.return_string)
ret.set_string("");
else
ret.set_int(0);
return;
}
this.results[0] = ret;
ret.object_class = this.object_type;		// so expression can access family type if need be
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++) {
this.parameters[i].get(this.temp);
this.results[i + 1] = this.temp.data;   // passing actual javascript value as argument instead of expvalue
}
var index = this.owner.solindex;
if (this.instance_expr) {
this.instance_expr.get(this.temp);
if (this.temp.is_number()) {
index = this.temp.data;
instances = this.object_type.instances;    // pick from all instances, not SOL
}
}
index %= instances.length;      // wraparound
if (index < 0)
index += instances.length;
var returned_val;
if (this.beh_index > -1)
returned_val = this.func.apply(instances[index].behavior_insts[this.beh_index], this.results);
else
returned_val = this.func.apply(instances[index], this.results);
;
};
expNodeProto.eval_instvar_exp = function (ret)
{
var sol = this.object_type.getCurrentSol();
var instances = sol.getObjects();
if (!instances.length)
{
if (this.return_string)
ret.set_string("");
else
ret.set_int(0);
return;
}
var index = this.owner.solindex;
if (this.instance_expr)
{
this.instance_expr.get(this.temp);
if (this.temp.is_number())
{
index = this.temp.data;
var type_instances = this.object_type.instances;
index %= type_instances.length;     // wraparound
if (index < 0)                      // offset
index += type_instances.length;
var to_ret = type_instances[index].instance_vars[this.varindex];
if (cr.is_string(to_ret))
ret.set_string(to_ret);
else
ret.set_float(to_ret);
return;         // done
}
}
index %= instances.length;      // wraparound
if (index < 0)
index += instances.length;
var inst = instances[index];
var offset = 0;
if (this.object_type.is_family)
{
offset = inst.type.family_var_map[this.object_type.family_index];
}
var to_ret = inst.instance_vars[this.varindex + offset];
if (cr.is_string(to_ret))
ret.set_string(to_ret);
else
ret.set_float(to_ret);
};
expNodeProto.eval_int = function (ret)
{
ret.type = cr.exptype.Integer;
ret.data = this.value;
};
expNodeProto.eval_float = function (ret)
{
ret.type = cr.exptype.Float;
ret.data = this.value;
};
expNodeProto.eval_string = function (ret)
{
ret.type = cr.exptype.String;
ret.data = this.value;
};
expNodeProto.eval_unaryminus = function (ret)
{
this.first.get(ret);                // retrieve operand
if (ret.is_number())
ret.data = -ret.data;
};
expNodeProto.eval_add = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data += this.temp.data;          // both operands numbers: add
if (this.temp.is_float())
ret.make_float();
}
};
expNodeProto.eval_subtract = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data -= this.temp.data;          // both operands numbers: subtract
if (this.temp.is_float())
ret.make_float();
}
};
expNodeProto.eval_multiply = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data *= this.temp.data;          // both operands numbers: multiply
if (this.temp.is_float())
ret.make_float();
}
};
expNodeProto.eval_divide = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data /= this.temp.data;          // both operands numbers: divide
ret.make_float();
}
};
expNodeProto.eval_mod = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data %= this.temp.data;          // both operands numbers: modulo
if (this.temp.is_float())
ret.make_float();
}
};
expNodeProto.eval_power = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data = Math.pow(ret.data, this.temp.data);   // both operands numbers: raise to power
if (this.temp.is_float())
ret.make_float();
}
};
expNodeProto.eval_and = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number())
{
if (this.temp.is_string())
{
ret.set_string(ret.data.toString() + this.temp.data);
}
else
{
if (ret.data && this.temp.data)
ret.set_int(1);
else
ret.set_int(0);
}
}
else if (ret.is_string())
{
if (this.temp.is_string())
ret.data += this.temp.data;
else
{
ret.data += (Math.round(this.temp.data * 1e10) / 1e10).toString();
}
}
};
expNodeProto.eval_or = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
if (ret.data || this.temp.data)
ret.set_int(1);
else
ret.set_int(0);
}
};
expNodeProto.eval_conditional = function (ret)
{
this.first.get(ret);                // condition operand
if (ret.data)                       // is true
this.second.get(ret);           // evaluate second operand to ret
else
this.third.get(ret);            // evaluate third operand to ret
};
expNodeProto.eval_equal = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data === this.temp.data ? 1 : 0);
};
expNodeProto.eval_notequal = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data !== this.temp.data ? 1 : 0);
};
expNodeProto.eval_less = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data < this.temp.data ? 1 : 0);
};
expNodeProto.eval_lessequal = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data <= this.temp.data ? 1 : 0);
};
expNodeProto.eval_greater = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data > this.temp.data ? 1 : 0);
};
expNodeProto.eval_greaterequal = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data >= this.temp.data ? 1 : 0);
};
expNodeProto.eval_eventvar_exp = function (ret)
{
if (cr.is_number(this.eventvar.data))
ret.set_float(this.eventvar.data);
else
ret.set_string(this.eventvar.data);
};
cr.expvalue = function (type, data)
{
this.type = type || cr.exptype.Integer;
this.data = data || 0;
this.object_class = null;
;
;
;
if (this.type == cr.exptype.Integer)
this.data = Math.floor(this.data);
cr.seal(this);
};
var expvalueProto = cr.expvalue.prototype;
expvalueProto.is_int = function ()
{
return this.type === cr.exptype.Integer;
};
expvalueProto.is_float = function ()
{
return this.type === cr.exptype.Float;
};
expvalueProto.is_number = function ()
{
return this.type === cr.exptype.Integer || this.type === cr.exptype.Float;
};
expvalueProto.is_string = function ()
{
return this.type === cr.exptype.String;
};
expvalueProto.make_int = function ()
{
if (!this.is_int())
{
if (this.is_float())
this.data = Math.floor(this.data);      // truncate float
else if (this.is_string())
this.data = parseInt(this.data, 10);
this.type = cr.exptype.Integer;
}
};
expvalueProto.make_float = function ()
{
if (!this.is_float())
{
if (this.is_string())
this.data = parseFloat(this.data);
this.type = cr.exptype.Float;
}
};
expvalueProto.make_string = function ()
{
if (!this.is_string())
{
this.data = this.data.toString();
this.type = cr.exptype.String;
}
};
expvalueProto.set_int = function (val)
{
;
this.type = cr.exptype.Integer;
this.data = Math.floor(val);
};
expvalueProto.set_float = function (val)
{
;
this.type = cr.exptype.Float;
this.data = val;
};
expvalueProto.set_string = function (val)
{
;
this.type = cr.exptype.String;
this.data = val;
};
expvalueProto.set_any = function (val)
{
if (cr.is_number(val))
{
this.type = cr.exptype.Float;
this.data = val;
}
else if (cr.is_string(val))
{
this.type = cr.exptype.String;
this.data = val.toString();
}
else
{
this.type = cr.exptype.Integer;
this.data = 0;
}
};
cr.exptype = {
Integer: 0,     // emulated; no native integer support in javascript
Float: 1,
String: 2
};
}());
;
cr.system_object = function (runtime)
{
this.runtime = runtime;
this.waits = [];
};
(function ()
{
var sysProto = cr.system_object.prototype;
sysProto.cnds = {};
sysProto.acts = {};
sysProto.exps = {};
var syscnds = sysProto.cnds;
syscnds.EveryTick = function()
{
return true;
};
syscnds.OnLayoutStart = function()
{
return true;
};
syscnds.OnLayoutEnd = function()
{
return true;
};
syscnds.Compare = function(x, cmp, y)
{
return cr.do_cmp(x, cmp, y);
};
syscnds.CompareTime = function (cmp, t)
{
var elapsed = this.runtime.kahanTime.sum;
if (cmp === 0)
{
var cnd = this.runtime.getCurrentCondition();
if (!cnd.extra.CompareTime_executed)
{
if (elapsed >= t)
{
cnd.extra.CompareTime_executed = true;
return true;
}
}
return false;
}
return cr.do_cmp(elapsed, cmp, t);
};
syscnds.LayerVisible = function (layer)
{
if (!layer)
return false;
else
return layer.visible;
};
syscnds.LayerCmpOpacity = function (layer, cmp, opacity_)
{
if (!layer)
return false;
return cr.do_cmp(layer.opacity * 100, cmp, opacity_);
};
syscnds.Repeat = function (count)
{
var current_frame = this.runtime.getCurrentEventStack();
var current_event = current_frame.current_event;
var solModifierAfterCnds = current_frame.isModifierAfterCnds();
var current_loop = this.runtime.pushLoopStack();
var i;
if (solModifierAfterCnds)
{
for (i = 0; i < count && !current_loop.stopped; i++)
{
this.runtime.pushCopySol(current_event.solModifiers);
current_loop.index = i;
current_event.retrigger();
this.runtime.popSol(current_event.solModifiers);
}
}
else
{
for (i = 0; i < count && !current_loop.stopped; i++)
{
current_loop.index = i;
current_event.retrigger();
}
}
this.runtime.popLoopStack();
return false;
};
syscnds.For = function (name, start, end)
{
var current_frame = this.runtime.getCurrentEventStack();
var current_event = current_frame.current_event;
var solModifierAfterCnds = current_frame.isModifierAfterCnds();
var current_loop = this.runtime.pushLoopStack(name);
var i;
if (solModifierAfterCnds)
{
for (i = start; i <= end && !current_loop.stopped; i++)  // inclusive to end
{
this.runtime.pushCopySol(current_event.solModifiers);
current_loop.index = i;
current_event.retrigger();
this.runtime.popSol(current_event.solModifiers);
}
}
else
{
for (i = start; i <= end && !current_loop.stopped; i++)  // inclusive to end
{
current_loop.index = i;
current_event.retrigger();
}
}
this.runtime.popLoopStack();
return false;
};
syscnds.ForEach = function (obj)
{
var sol = obj.getCurrentSol();
var instances = sol.getObjects().slice(0);
var current_frame = this.runtime.getCurrentEventStack();
var current_event = current_frame.current_event;
var solModifierAfterCnds = current_frame.isModifierAfterCnds();
var current_loop = this.runtime.pushLoopStack(name);
var i, len;
if (solModifierAfterCnds)
{
for (i = 0, len = instances.length; i < len && !current_loop.stopped; i++)
{
this.runtime.pushCopySol(current_event.solModifiers);
sol = obj.getCurrentSol();
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = instances[i];
current_loop.index = i;
current_event.retrigger();
this.runtime.popSol(current_event.solModifiers);
}
}
else
{
sol.select_all = false;
sol.instances.length = 1;
for (i = 0, len = instances.length; i < len && !current_loop.stopped; i++)
{
sol.instances[0] = instances[i];
current_loop.index = i;
current_event.retrigger();
}
}
this.runtime.popLoopStack();
return false;
};
syscnds.TriggerOnce = function ()
{
var cnd = this.runtime.getCurrentCondition();
var last_tick = cnd.extra.TriggerOnce_lastTick || 0;
var cur_tick = this.runtime.tickcount;
cnd.extra.TriggerOnce_lastTick = cur_tick;
return this.runtime.layout_first_tick || !(last_tick === cur_tick - 1);
};
syscnds.Every = function (seconds)
{
var cnd = this.runtime.getCurrentCondition();
var last_time = cnd.extra.Every_lastTime || 0;
var cur_time = this.runtime.kahanTime.sum;
if (cur_time >= last_time + seconds)
{
cnd.extra.Every_lastTime = last_time + seconds;
if (cur_time >= cnd.extra.Every_lastTime + seconds)
cnd.extra.Every_lastTime = cur_time;
return true;
}
else
return false;
};
syscnds.PickNth = function (obj, index)
{
if (!obj)
return false;
var sol = obj.getCurrentSol();
var instances = sol.getObjects();
index = Math.floor(index);
if (index < 0 || index >= instances.length)
return false;
var inst = instances[index];
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = inst;
return true;
};
syscnds.PickRandom = function (obj)
{
if (!obj)
return false;
var sol = obj.getCurrentSol();
var instances = sol.getObjects();
var index = Math.floor(Math.random() * instances.length);
if (index >= instances.length)
return false;
var inst = instances[index];
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = inst;
return true;
};
syscnds.CompareVar = function (v, cmp, val)
{
return cr.do_cmp(v.data, cmp, val);
};
syscnds.IsGroupActive = function (group)
{
return this.runtime.activeGroups.hasOwnProperty((/*this.runtime.getCurrentCondition().sheet.name + "|" + */group).toLowerCase());
};
syscnds.IsPreview = function ()
{
return typeof cr_is_preview !== "undefined";
};
syscnds.PickAll = function (obj)
{
if (!obj)
return false;
if (!obj.instances.length)
return false;
var sol = obj.getCurrentSol();
sol.select_all = true;
return true;
};
syscnds.IsMobile = function ()
{
return this.runtime.isMobile;
};
var sysacts = sysProto.acts;
sysacts.GoToLayout = function(to)
{
;
this.runtime.changelayout = to;
};
sysacts.CreateObject = function (obj, layer, x, y)
{
if (!layer || !obj)
return;
var inst = this.runtime.createInstance(obj, layer, x, y);
var sol = inst.type.getCurrentSol();
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = inst;
};
sysacts.SetLayerVisible = function (layer, visible_)
{
if (!layer)
return;
if (layer.visible !== visible_)
{
layer.visible = visible_;
this.runtime.redraw = true;
}
};
sysacts.SetLayerOpacity = function (layer, opacity_)
{
if (!layer)
return;
opacity_ = cr.clamp(opacity_ / 100, 0, 1);
if (layer.opacity !== opacity_)
{
layer.opacity = opacity_;
this.runtime.redraw = true;
}
};
sysacts.SetLayerScaleRate = function (layer, sr)
{
if (!layer)
return;
if (layer.zoomRate !== sr)
{
layer.zoomRate = sr;
this.runtime.redraw = true;
}
};
sysacts.SetLayoutScale = function (s)
{
if (!this.runtime.running_layout)
return;
if (this.runtime.running_layout.scale !== s)
{
this.runtime.running_layout.scale = s;
this.runtime.redraw = true;
}
};
sysacts.ScrollX = function(x)
{
this.runtime.running_layout.scrollToX(x);
};
sysacts.ScrollY = function(y)
{
this.runtime.running_layout.scrollToY(y);
};
sysacts.Scroll = function(x, y)
{
this.runtime.running_layout.scrollToX(x);
this.runtime.running_layout.scrollToY(y);
};
sysacts.ScrollToObject = function(obj)
{
var inst = obj.getFirstPicked();
if (inst)
{
this.runtime.running_layout.scrollToX(inst.x);
this.runtime.running_layout.scrollToY(inst.y);
}
};
sysacts.SetVar = function(v, x)
{
if (v.vartype === 0)
{
if (cr.is_number(x))
v.data = x;
else
v.data = parseFloat(x);
}
else if (v.vartype === 1)
v.data = x.toString();
};
sysacts.AddVar = function(v, x)
{
if (v.vartype === 0)
{
if (cr.is_number(x))
v.data += x;
else
v.data += parseFloat(x);
}
else if (v.vartype === 1)
v.data += x.toString();
};
sysacts.SubVar = function(v, x)
{
if (v.vartype === 0)
{
if (cr.is_number(x))
v.data -= x;
else
v.data -= parseFloat(x);
}
};
sysacts.SetGroupActive = function (group, active)
{
var activeGroups = this.runtime.activeGroups;
var groupkey = (/*this.runtime.getCurrentAction().sheet.name + "|" + */group).toLowerCase();
switch (active) {
case 0:
delete activeGroups[groupkey];
break;
case 1:
activeGroups[groupkey] = true;
break;
case 2:
if (activeGroups[groupkey])
delete activeGroups[groupkey];
else
activeGroups[groupkey] = true;
break;
}
};
sysacts.SetTimescale = function (ts_)
{
var ts = ts_;
if (ts < 0)
ts = 0;
this.runtime.timescale = ts;
};
sysacts.SetObjectTimescale = function (obj, ts_)
{
var ts = ts_;
if (ts < 0)
ts = 0;
if (!obj)
return;
var sol = obj.getCurrentSol();
var instances = sol.getObjects();
var i, len;
for (i = 0, len = instances.length; i < len; i++)
{
instances[i].my_timescale = ts;
}
};
sysacts.RestoreObjectTimescale = function (obj)
{
if (!obj)
return false;
var sol = obj.getCurrentSol();
var instances = sol.getObjects();
var i, len;
for (i = 0, len = instances.length; i < len; i++)
{
instances[i].my_timescale = -1.0;
}
};
sysacts.Wait = function (seconds)
{
if (seconds < 0)
return;
var i, len, s, t;
var evinfo = this.runtime.getCurrentEventStack();
var waitobj = {};
waitobj.time = this.runtime.kahanTime.sum + seconds;
waitobj.ev = evinfo.current_event;
waitobj.actindex = evinfo.actindex + 1;	// pointing at next action
waitobj.deleteme = false;
waitobj.sols = {};
waitobj.solModifiers = [];
for (i = 0, len = this.runtime.types_by_index.length; i < len; i++)
{
t = this.runtime.types_by_index[i];
s = t.getCurrentSol();
if (s.select_all)
continue;
waitobj.solModifiers.push(t);
waitobj.sols[i.toString()] = s.instances.slice(0);
}
this.waits.push(waitobj);
return true;
};
sysacts.SetLayerScale = function (layer, scale)
{
if (!layer)
return;
if (layer.scale === scale)
return;
layer.scale = scale;
this.runtime.redraw = true;
};
sysacts.ResetGlobals = function ()
{
var i, len, g;
for (i = 0, len = this.runtime.all_global_vars.length; i < len; i++)
{
g = this.runtime.all_global_vars[i];
g.data = g.initial;
}
};
sysacts.SetLayoutAngle = function (a)
{
a = cr.to_radians(a);
a = cr.clamp_angle(a);
if (this.runtime.running_layout)
{
if (this.runtime.running_layout.angle !== a)
{
this.runtime.running_layout.angle = a;
this.runtime.redraw = true;
}
}
};
sysacts.SetLayerAngle = function (layer, a)
{
if (!layer)
return;
a = cr.to_radians(a);
a = cr.clamp_angle(a);
if (layer.angle === a)
return;
layer.angle = a;
this.runtime.redraw = true;
};
sysacts.StopLoop = function ()
{
if (this.runtime.loop_stack_index < 0)
return;		// no loop currently running
this.runtime.getCurrentLoop().stopped = true;
};
sysacts.GoToLayoutByName = function (layoutname)
{
;
var l;
for (l in this.runtime.layouts)
{
if (this.runtime.layouts.hasOwnProperty(l) && l.toLowerCase() === layoutname.toLowerCase())
{
this.runtime.changelayout = this.runtime.layouts[l];
return;
}
}
};
var sysexps = sysProto.exps;
sysexps["int"] = function(ret, x)
{
if (cr.is_string(x))
{
ret.set_int(parseInt(x, 10));
if (isNaN(ret.data))
ret.data = 0;
}
else
ret.set_int(x);
};
sysexps["float"] = function(ret, x)
{
if (cr.is_string(x))
{
ret.set_float(parseFloat(x));
if (isNaN(ret.data))
ret.data = 0;
}
else
ret.set_float(x);
};
sysexps.str = function(ret, x)
{
if (cr.is_string(x))
ret.set_string(x);
else
ret.set_string(x.toString());
};
sysexps.len = function(ret, x)
{
ret.set_int(x.length || 0);
};
sysexps.random = function (ret, a, b)
{
if (b === undefined)
{
ret.set_float(Math.random() * a);
}
else
{
ret.set_float(Math.random() * (b - a) + a);
}
};
sysexps.sqrt = function(ret, x)
{
ret.set_float(Math.sqrt(x));
};
sysexps.abs = function(ret, x)
{
ret.set_float(Math.abs(x));
};
sysexps.round = function(ret, x)
{
ret.set_int(Math.round(x));
};
sysexps.floor = function(ret, x)
{
ret.set_int(Math.floor(x));
};
sysexps.ceil = function(ret, x)
{
ret.set_int(Math.ceil(x));
};
sysexps.sin = function(ret, x)
{
ret.set_float(Math.sin(cr.to_radians(x)));
};
sysexps.cos = function(ret, x)
{
ret.set_float(Math.cos(cr.to_radians(x)));
};
sysexps.tan = function(ret, x)
{
ret.set_float(Math.tan(cr.to_radians(x)));
};
sysexps.asin = function(ret, x)
{
ret.set_float(cr.to_degrees(Math.asin(x)));
};
sysexps.acos = function(ret, x)
{
ret.set_float(cr.to_degrees(Math.acos(x)));
};
sysexps.atan = function(ret, x)
{
ret.set_float(cr.to_degrees(Math.atan(x)));
};
sysexps.exp = function(ret, x)
{
ret.set_float(Math.exp(x));
};
sysexps.ln = function(ret, x)
{
ret.set_float(Math.log(x));
};
sysexps.log10 = function(ret, x)
{
ret.set_float(Math.log(x) / Math.LN10);
};
sysexps.max = function(ret)
{
var max_ = arguments[1];
var i, len;
for (i = 2, len = arguments.length; i < len; i++)
{
if (max_ < arguments[i])
max_ = arguments[i];
}
ret.set_float(max_);
};
sysexps.min = function(ret)
{
var min_ = arguments[1];
var i, len;
for (i = 2, len = arguments.length; i < len; i++)
{
if (min_ > arguments[i])
min_ = arguments[i];
}
ret.set_float(min_);
};
sysexps.dt = function(ret)
{
ret.set_float(this.runtime.dt);
};
sysexps.timescale = function(ret)
{
ret.set_float(this.runtime.timescale);
};
sysexps.wallclocktime = function(ret)
{
ret.set_float((Date.now() - this.runtime.start_time) / 1000.0);
};
sysexps.time = function(ret)
{
ret.set_float(this.runtime.kahanTime.sum);
};
sysexps.tickcount = function(ret)
{
ret.set_int(this.runtime.tickcount);
};
sysexps.objectcount = function(ret)
{
ret.set_int(this.runtime.objectcount);
};
sysexps.fps = function(ret)
{
ret.set_int(this.runtime.fps);
};
sysexps.loopindex = function(ret, name_)
{
if (!this.runtime.loop_stack.length)
{
ret.set_int(0);
return;
}
if (name_)
{
var i, len;
for (i = 0, len = this.runtime.loop_stack.length; i < len; i++)
{
var loop = this.runtime.loop_stack[i];
if (loop.name === name_)
{
ret.set_int(loop.index);
return;
}
}
ret.set_int(0);
}
else
{
ret.set_int(this.runtime.getCurrentLoop().index);
}
};
sysexps.distance = function(ret, x1, y1, x2, y2)
{
ret.set_float(cr.distanceTo(x1, y1, x2, y2));
};
sysexps.angle = function(ret, x1, y1, x2, y2)
{
ret.set_float(cr.to_degrees(cr.angleTo(x1, y1, x2, y2)));
};
sysexps.scrollx = function(ret)
{
ret.set_float(this.runtime.running_layout.scrollX);
};
sysexps.scrolly = function(ret)
{
ret.set_float(this.runtime.running_layout.scrollY);
};
sysexps.newline = function(ret)
{
ret.set_string("\n");
};
sysexps.lerp = function(ret, a, b, x)
{
ret.set_float(cr.lerp(a, b, x));
};
sysexps.windowwidth = function(ret)
{
ret.set_int(this.runtime.width);
};
sysexps.windowheight = function(ret)
{
ret.set_int(this.runtime.height);
};
sysexps.uppercase = function(ret, str)
{
ret.set_string(str.toUpperCase());
};
sysexps.lowercase = function(ret, str)
{
ret.set_string(str.toLowerCase());
};
sysexps.clamp = function(ret, x, l, u)
{
if (x < l)
ret.set_float(l);
else if (x > u)
ret.set_float(u);
else
ret.set_float(x);
};
sysexps.layerscale = function (ret, layerparam)
{
var layer = this.runtime.getLayer(layerparam);
if (!layer)
ret.set_float(0);
else
ret.set_float(layer.scale);
};
sysexps.layeropacity = function (ret, layerparam)
{
var layer = this.runtime.getLayer(layerparam);
if (!layer)
ret.set_float(0);
else
ret.set_float(layer.opacity * 100);
};
sysexps.layerscalerate = function (ret, layerparam)
{
var layer = this.runtime.getLayer(layerparam);
if (!layer)
ret.set_float(0);
else
ret.set_float(layer.zoomRate);
};
sysexps.layoutscale = function (ret)
{
if (this.runtime.running_layout)
ret.set_float(this.runtime.running_layout.scale);
else
ret.set_float(0);
};
sysexps.layoutangle = function (ret)
{
ret.set_float(cr.to_degrees(this.runtime.running_layout.angle));
};
sysexps.layerangle = function (ret, layerparam)
{
var layer = this.runtime.getLayer(layerparam);
if (!layer)
ret.set_float(0);
else
ret.set_float(cr.to_degrees(layer.angle));
};
sysexps.layoutwidth = function (ret)
{
ret.set_int(this.runtime.running_layout.width);
};
sysexps.layoutheight = function (ret)
{
ret.set_int(this.runtime.running_layout.height);
};
sysexps.find = function (ret, text, searchstr)
{
ret.set_int(text.search(new RegExp(cr.regexp_escape(searchstr), "i")));
};
sysexps.left = function (ret, text, n)
{
ret.set_string(text.substr(0, n));
};
sysexps.right = function (ret, text, n)
{
ret.set_string(text.substr(text.length - n));
};
sysexps.mid = function (ret, text, index_, length_)
{
ret.set_string(text.substr(index_, length_));
};
sysexps.tokenat = function (ret, text, index_, sep)
{
var arr = text.split(sep);
var i = Math.floor(index_);
if (i < 0 || i >= arr.length)
ret.set_string("");
else
ret.set_string(arr[i]);
};
sysexps.tokencount = function (ret, text, sep)
{
if (!text.length)
return 0;		// empty string has no tokens (otherwise reports 1)
ret.set_int(text.split(sep).length);
};
sysexps.replace = function (ret, text, find_, replace_)
{
ret.set_string(text.replace(new RegExp(cr.regexp_escape(find_), "gi"), replace_));
};
sysexps.trim = function (ret, text)
{
ret.set_string(text.trim());
};
sysexps.pi = function (ret)
{
ret.set_float(Math.PI);
};
sysexps.layoutname = function (ret)
{
if (this.runtime.running_layout)
ret.set_string(this.runtime.running_layout.name);
else
ret.set_string("");
};
sysexps.renderer = function (ret)
{
ret.set_string(this.runtime.gl ? "webgl" : "canvas2d");
};
sysexps.anglediff = function (ret, a, b)
{
ret.set_float(cr.to_degrees(cr.angleDiff(cr.to_radians(a), cr.to_radians(b))));
};
sysexps.choose = function (ret)
{
var index = Math.floor(Math.random() * (arguments.length - 1));
ret.set_any(arguments[index + 1]);
};
sysexps.rgb = function (ret, r, g, b)
{
ret.set_int(cr.RGB(r, g, b));
};
sysexps.projectversion = function (ret)
{
ret.set_string(this.runtime.versionstr);
};
sysexps.anglelerp = function (ret, a, b, x)
{
a = cr.to_radians(a);
b = cr.to_radians(b);
var diff = cr.angleDiff(a, b);
if (cr.angleClockwise(b, a))
{
ret.set_float(cr.to_clamped_degrees(a + diff * x));
}
else
{
ret.set_float(cr.to_clamped_degrees(a - diff * x));
}
};
sysProto.runWaits = function ()
{
var i, j, len, w, k, s;
var evinfo = this.runtime.getCurrentEventStack();
for (i = 0, len = this.waits.length; i < len; i++)
{
w = this.waits[i];
if (w.time > this.runtime.kahanTime.sum)
continue;
evinfo.current_event = w.ev;
evinfo.actindex = w.actindex;
evinfo.cndindex = 0;
for (k in w.sols)
{
if (w.sols.hasOwnProperty(k))
{
s = this.runtime.types_by_index[parseInt(k, 10)].getCurrentSol();
s.select_all = false;
s.instances = w.sols[k];
}
}
w.ev.resume_actions_and_subevents();
this.runtime.clearSol(w.solModifiers);
w.deleteme = true;
}
for (i = 0, j = 0, len = this.waits.length; i < len; i++)
{
w = this.waits[i];
this.waits[j] = w;
if (!w.deleteme)
j++;
}
this.waits.length = j;
};
}());
;
cr.add_common_aces = function (m)
{
var pluginProto = m[0].prototype;	
var singleglobal = m[1];
var is_world = m[2];
var position_aces = m[3];
var size_aces = m[4];
var angle_aces = m[5];
var appearance_aces = m[6];
var zorder_aces = m[7];
if (!pluginProto.cnds)
pluginProto.cnds = {};
if (!pluginProto.acts)
pluginProto.acts = {};
if (!pluginProto.exps)
pluginProto.exps = {};
var cnds = pluginProto.cnds;
var acts = pluginProto.acts;
var exps = pluginProto.exps;
if (position_aces)
{
cnds.CompareX = function (cmp, x)
{
return cr.do_cmp(this.x, cmp, x);
};
cnds.CompareY = function (cmp, y)
{
return cr.do_cmp(this.y, cmp, y);
};
cnds.IsOnScreen = function ()
{
var layer = this.layer;				
this.update_bbox();
var bbox = this.bbox;
return !(bbox.right < layer.viewLeft || bbox.bottom < layer.viewTop || bbox.left > layer.viewRight || bbox.top > layer.viewBottom);
};
cnds.IsOutsideLayout = function ()
{
this.update_bbox();
var bbox = this.bbox;
var layout = this.runtime.running_layout;
return (bbox.right < 0 || bbox.bottom < 0 || bbox.left > layout.width || bbox.top > layout.height);
};
cnds.PickDistance = function (which, x, y)
{
var sol = this.getCurrentSol();
var instances = sol.getObjects();
if (!instances.length)
return false;
var inst = instances[0];
var pickme = inst;
var dist = cr.distanceTo(inst.x, inst.y, x, y);
var i, len, d;
for (i = 1, len = instances.length; i < len; i++)
{
inst = instances[i];
d = cr.distanceTo(inst.x, inst.y, x, y);
if ((which === 0 && d < dist) || (which === 1 && d > dist))
{
dist = d;
pickme = inst;
}
}
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = pickme;
return true;
};
acts.SetX = function (x)
{
if (this.x !== x)
{
this.x = x;
this.set_bbox_changed();
}
};
acts.SetY = function (y)
{
if (this.y !== y)
{
this.y = y;
this.set_bbox_changed();
}
};
acts.SetPos = function (x, y)
{
if (this.x !== x || this.y !== y)
{
this.x = x;
this.y = y;
this.set_bbox_changed();
}
};
acts.SetPosToObject = function (obj, imgpt)
{
var inst = obj.getPairedInstance(this);
if (!inst)
return;
var newx, newy;
if (inst.getImagePoint)
{
newx = inst.getImagePoint(imgpt, true);
newy = inst.getImagePoint(imgpt, false);
}
else
{
newx = inst.x;
newy = inst.y;
}
if (this.x !== newx || this.y !== newy)
{
this.x = newx;
this.y = newy;
this.set_bbox_changed();
}
};
acts.MoveForward = function (dist)
{
if (dist !== 0)
{
this.x += Math.cos(this.angle) * dist;
this.y += Math.sin(this.angle) * dist;
this.set_bbox_changed();
}
};
acts.MoveAtAngle = function (a, dist)
{
if (dist !== 0)
{
this.x += Math.cos(cr.to_radians(a)) * dist;
this.y += Math.sin(cr.to_radians(a)) * dist;
this.set_bbox_changed();
}
};
exps.X = function (ret)
{
ret.set_float(this.x);
};
exps.Y = function (ret)
{
ret.set_float(this.y);
};
exps.dt = function (ret)
{
ret.set_float(this.runtime.getDt(this));
};
}
if (size_aces)
{
cnds.CompareWidth = function (cmp, w)
{
return cr.do_cmp(this.width, cmp, w);
};
cnds.CompareHeight = function (cmp, h)
{
return cr.do_cmp(this.height, cmp, h);
};
acts.SetWidth = function (w)
{
var newwidth = w;
if (newwidth < 0)
newwidth = -newwidth;
if (this.width !== newwidth)
{
this.width = newwidth;
this.set_bbox_changed();
}
};
acts.SetHeight = function (h)
{
var newheight = h;
if (newheight < 0)
newheight = -newheight;
if (this.height !== newheight)
{
this.height = newheight;
this.set_bbox_changed();
}
};
acts.SetSize = function (w, h)
{
var newwidth = w;
var newheight = h;
if (newwidth < 0)
newwidth = -newwidth;
if (newheight < 0)
newheight = -newheight;
if (this.width !== newwidth || this.height !== newheight)
{
this.width = newwidth;
this.height = newheight;
this.set_bbox_changed();
}
};
exps.Width = function (ret)
{
ret.set_float(this.width);
};
exps.Height = function (ret)
{
ret.set_float(this.height);
};
}
if (angle_aces)
{
cnds.AngleWithin = function (within, a)
{
return cr.angleDiff(this.angle, cr.to_radians(a)) <= cr.to_radians(within);
};
cnds.IsClockwiseFrom = function (a)
{
return cr.angleClockwise(this.angle, cr.to_radians(a));
};
cnds.IsBetweenAngles = function (a, b)
{
var lower = cr.to_clamped_radians(a);
var upper = cr.to_clamped_radians(b);
var angle = cr.clamp_angle(this.angle);
return cr.angleClockwise(angle, lower) && !cr.angleClockwise(angle, upper);
};
acts.SetAngle = function (a)
{
var newangle = cr.to_radians(cr.clamp_angle_degrees(a));
if (isNaN(newangle))
return;
if (this.angle !== newangle)
{
this.angle = newangle;
this.set_bbox_changed();
}
};
acts.RotateClockwise = function (a)
{
if (a !== 0 && !isNaN(a))
{
this.angle += cr.to_radians(a);
this.angle = cr.clamp_angle(this.angle);
this.set_bbox_changed();
}
};
acts.RotateCounterclockwise = function (a)
{
if (a !== 0 && !isNaN(a))
{
this.angle -= cr.to_radians(a);
this.angle = cr.clamp_angle(this.angle);
this.set_bbox_changed();
}
};
acts.RotateTowardAngle = function (amt, target)
{
var newangle = cr.angleRotate(this.angle, cr.to_radians(target), cr.to_radians(amt));
if (isNaN(newangle))
return;
if (this.angle !== newangle)
{
this.angle = newangle;
this.set_bbox_changed();
}
};
acts.RotateTowardPosition = function (amt, x, y)
{
var dx = x - this.x;
var dy = y - this.y;
var target = Math.atan2(dy, dx);
var newangle = cr.angleRotate(this.angle, target, cr.to_radians(amt));
if (isNaN(newangle))
return;
if (this.angle !== newangle)
{
this.angle = newangle;
this.set_bbox_changed();
}
};
acts.SetTowardPosition = function (x, y)
{
var dx = x - this.x;
var dy = y - this.y;
var newangle = Math.atan2(dy, dx);
if (isNaN(newangle))
return;
if (this.angle !== newangle)
{
this.angle = newangle;
this.set_bbox_changed();
}
};
exps.Angle = function (ret)
{
ret.set_float(cr.to_clamped_degrees(this.angle));
};
}
if (!singleglobal)
{
cnds.CompareInstanceVar = function (iv, cmp, val)
{
return cr.do_cmp(this.instance_vars[iv], cmp, val);
};
cnds.IsBoolInstanceVarSet = function (iv)
{
return this.instance_vars[iv];
};
cnds.PickByUID = function (u)
{
return this.uid === u;
};
acts.SetInstanceVar = function (iv, val)
{
if (cr.is_number(this.instance_vars[iv]))
{
if (cr.is_number(val))
this.instance_vars[iv] = val;
else
this.instance_vars[iv] = parseFloat(val);
}
else if (cr.is_string(this.instance_vars[iv]))
{
if (cr.is_string(val))
this.instance_vars[iv] = val;
else
this.instance_vars[iv] = val.toString();
}
else
;
};
acts.AddInstanceVar = function (iv, val)
{
if (cr.is_number(this.instance_vars[iv]))
{
if (cr.is_number(val))
this.instance_vars[iv] += val;
else
this.instance_vars[iv] += parseFloat(val);
}
else if (cr.is_string(this.instance_vars[iv]))
{
if (cr.is_string(val))
this.instance_vars[iv] += val;
else
this.instance_vars[iv] += val.toString();
}
else
;
};
acts.SubInstanceVar = function (iv, val)
{
if (cr.is_number(this.instance_vars[iv]))
{
if (cr.is_number(val))
this.instance_vars[iv] -= val;
else
this.instance_vars[iv] -= parseFloat(val);
}
else
;
};
acts.SetBoolInstanceVar = function (iv, val)
{
this.instance_vars[iv] = val ? 1 : 0;
};
acts.ToggleBoolInstanceVar = function (iv)
{
this.instance_vars[iv] = 1 - this.instance_vars[iv];
};
acts.Destroy = function ()
{
this.runtime.DestroyInstance(this);
};
exps.Count = function (ret)
{
ret.set_int(ret.object_class.instances.length);
};
exps.UID = function (ret)
{
ret.set_int(this.uid);
};
exps.IID = function (ret)
{
ret.set_int(this.get_iid());
};
}
if (appearance_aces)
{
cnds.IsVisible = function ()
{
return this.visible && this.layer.visible;
};
acts.SetVisible = function (v)
{
if (!v !== !this.visible)
{
this.visible = v;
this.runtime.redraw = true;
}
};
cnds.CompareOpacity = function (cmp, x)
{
return cr.do_cmp(this.opacity * 100, cmp, x);
};
acts.SetOpacity = function (x)
{
var new_opacity = x / 100.0;
if (new_opacity < 0)
new_opacity = 0;
else if (new_opacity > 1)
new_opacity = 1;
if (new_opacity !== this.opacity)
{
this.opacity = new_opacity;
this.runtime.redraw = true;
}
};
exps.Opacity = function (ret)
{
ret.set_float(this.opacity * 100.0);
};
}
if (zorder_aces)
{
cnds.IsOnLayer = function (layer_)
{
if (!layer_)
return false;
return this.layer === layer_;
};
cnds.PickTopBottom = function (which_)
{
var sol = this.getCurrentSol();
var instances = sol.getObjects();
if (!instances.length)
return false;
var inst = instances[0];
var pickme = inst;
var i, len;
for (i = 1, len = instances.length; i < len; i++)
{
inst = instances[i];
if (which_ === 0)
{
if (inst.layer.index > pickme.layer.index || (inst.layer.index === pickme.layer.index && inst.get_zindex() > pickme.get_zindex()))
{
pickme = inst;
}
}
else
{
if (inst.layer.index < pickme.layer.index || (inst.layer.index === pickme.layer.index && inst.get_zindex() < pickme.get_zindex()))
{
pickme = inst;
}
}
}
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = pickme;
return true;
};
acts.MoveToTop = function ()
{
var zindex = this.get_zindex();
if (zindex === this.layer.instances.length - 1)
return;
cr.arrayRemove(this.layer.instances, zindex);
this.layer.instances.push(this);
this.runtime.redraw = true;
this.layer.zindices_stale = true;
};
acts.MoveToBottom = function ()
{
var zindex = this.get_zindex();
if (zindex === 0)
return;
cr.arrayRemove(this.layer.instances, zindex);
this.layer.instances.unshift(this);
this.runtime.redraw = true;
this.layer.zindices_stale = true;
};
acts.MoveToLayer = function (layerMove)
{
if (!layerMove || layerMove == this.layer)
return;
cr.arrayRemove(this.layer.instances, this.get_zindex());
this.layer.zindices_stale = true;
this.layer = layerMove;
this.zindex = layerMove.instances.length;
layerMove.instances.push(this);
this.runtime.redraw = true;
};
exps.LayerNumber = function (ret)
{
ret.set_int(this.layer.number);
};
exps.LayerName = function (ret)
{
ret.set_string(this.layer.name);
};
exps.ZIndex = function (ret)
{
ret.set_int(this.get_zindex());
};
}
};
cr.set_bbox_changed = function ()
{
this.bbox_changed = true;       // will recreate next time box requested
this.runtime.redraw = true;     // assume runtime needs to redraw
var i, len;
for (i = 0, len = this.bbox_changed_callbacks.length; i < len; i++)
{
this.bbox_changed_callbacks[i](this);
}
};
cr.add_bbox_changed_callback = function (f)
{
if (f)
this.bbox_changed_callbacks.push(f);
};
cr.update_bbox = function ()
{
if (!this.bbox_changed)
return;                 // bounding box not changed
this.bbox.set(this.x, this.y, this.x + this.width, this.y + this.height);
this.bbox.offset(-this.hotspotX * this.width, -this.hotspotY * this.height);
if (!this.angle || this.angle === 0)
{
this.bquad.set_from_rect(this.bbox);    // make bounding quad from box
}
else
{
this.bbox.offset(-this.x, -this.y);       					// translate to origin
this.bquad.set_from_rotated_rect(this.bbox, this.angle);	// rotate around origin
this.bquad.offset(this.x, this.y);      					// translate back to original position
this.bquad.bounding_box(this.bbox);
}
var temp = 0;
if (this.bbox.left > this.bbox.right)
{
temp = this.bbox.left;
this.bbox.left = this.bbox.right;
this.bbox.right = temp;
}
if (this.bbox.top > this.bbox.bottom)
{
temp = this.bbox.top;
this.bbox.top = this.bbox.bottom;
this.bbox.bottom = temp;
}
this.bbox_changed = false;  // bounding box up to date
};
cr.inst_contains_pt = function (x, y)
{
if (!this.bbox.contains_pt(x, y))
return false;
if (!this.bquad.contains_pt(x, y))
return false;
if (this.collision_poly && !this.collision_poly.is_empty())
{
this.collision_poly.cache_poly(this.width, this.height, this.angle);
return this.collision_poly.contains_pt(x - this.x, y - this.y);
}
else
return true;
};
cr.inst_get_iid = function ()
{
this.type.updateIIDs();
return this.iid;
};
cr.inst_get_zindex = function ()
{
this.layer.updateZIndices();
return this.zindex;
};
cr.inst_toString = function ()
{
return "inst:" + this.type.name + "#" + this.uid;
};
cr.type_getFirstPicked = function ()
{
var instances = this.getCurrentSol().getObjects();
if (instances.length)
return instances[0];
else
return null;
};
cr.type_getPairedInstance = function (inst)
{
var instances = this.getCurrentSol().getObjects();
if (instances.length)
return instances[inst.get_iid() % instances.length];
else
return null;
};
cr.type_updateIIDs = function ()
{
if (!this.stale_iids || this.is_family)
return;		// up to date or is family - don't want family to overwrite IIDs
var i, len;
for (i = 0, len = this.instances.length; i < len; i++)
this.instances[i].iid = i;
this.stale_iids = false;
};
cr.type_getCurrentSol = function ()
{
return this.solstack[this.cur_sol];
};
cr.type_pushCleanSol = function ()
{
this.cur_sol++;
if (this.cur_sol === this.solstack.length)
this.solstack.push(new cr.selection(this));
else
this.solstack[this.cur_sol].select_all = true;  // else clear next SOL
};
cr.type_pushCopySol = function ()
{
this.cur_sol++;
if (this.cur_sol === this.solstack.length)
this.solstack.push(new cr.selection(this));
var clonesol = this.solstack[this.cur_sol];
var prevsol = this.solstack[this.cur_sol - 1];
if (prevsol.select_all)
clonesol.select_all = true;
else
{
clonesol.select_all = false;
clonesol.instances = prevsol.instances.slice(0);    // copy elements
}
};
cr.type_popSol = function ()
{
;
this.cur_sol--;
};
cr.type_getBehaviorByName = function (behname) {
var i, len;
for (i = 0, len = this.behaviors.length; i < len; i++) {
if (behname === this.behaviors[i].name)
return this.behaviors[i];
}
return null;
};
cr.type_getBehaviorIndexByName = function (behname) {
var i, len;
for (i = 0, len = this.behaviors.length; i < len; i++) {
if (behname === this.behaviors[i].name)
return i;
}
return -1;
};
cr.do_cmp = function (x, cmp, y)
{
switch (cmp)
{
case 0:     // equal
return x === y;
case 1:     // not equal
return x !== y;
case 2:     // less
return x < y;
case 3:     // less/equal
return x <= y;
case 4:     // greater
return x > y;
case 5:     // greater/equal
return x >= y;
default:
;
return false;
}
};
;
;
cr.plugins_.Mouse = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var pluginProto = cr.plugins_.Mouse.prototype;
pluginProto.Type = function(plugin)
{
this.plugin = plugin;
this.runtime = plugin.runtime;
};
var typeProto = pluginProto.Type.prototype;
typeProto.onCreate = function()
{
};
pluginProto.Instance = function(type)
{
this.type = type;
this.runtime = type.runtime;
this.buttonMap = new Array(4);		// mouse down states
this.mouseXcanvas = 0;				// mouse position relative to canvas
this.mouseYcanvas = 0;
this.triggerButton = 0;
this.triggerType = 0;
this.triggerDir = 0;
this.handled = false;
};
var instanceProto = pluginProto.Instance.prototype;
instanceProto.onCreate = function()
{
jQuery(document).mousemove(
(function (self) {
return function(info) {
self.onMouseMove(info);
};
})(this)
);
jQuery(document).mousedown(
(function (self) {
return function(info) {
self.onMouseDown(info);
};
})(this)
);
jQuery(document).mouseup(
(function (self) {
return function(info) {
self.onMouseUp(info);
};
})(this)
);
jQuery(document).dblclick(
(function (self) {
return function(info) {
self.onDoubleClick(info);
};
})(this)
);
var wheelevent = (function (self) {
return function(info) {
self.onWheel(info);
};
})(this);
document.addEventListener("mousewheel", wheelevent, false);
document.addEventListener("DOMMouseScroll", wheelevent, false);
};
var dummyoffset = {left: 0, top: 0};
instanceProto.onMouseMove = function(info)
{
var offset = this.runtime.isWebKitMode ? dummyoffset : jQuery(this.runtime.canvas).offset();
this.mouseXcanvas = info.pageX - offset.left;
this.mouseYcanvas = info.pageY - offset.top;
};
instanceProto.onMouseDown = function(info)
{
if (window == window.top)
info.preventDefault();
this.buttonMap[info.which] = true;
this.runtime.trigger(cr.plugins_.Mouse.prototype.cnds.OnAnyClick, this);
this.triggerButton = info.which - 1;	// 1-based
this.triggerType = 0;					// single click
this.runtime.trigger(cr.plugins_.Mouse.prototype.cnds.OnClick, this);
this.runtime.trigger(cr.plugins_.Mouse.prototype.cnds.OnObjectClicked, this);
};
instanceProto.onMouseUp = function(info)
{
if (window == window.top)
info.preventDefault();
this.buttonMap[info.which] = false;
this.triggerButton = info.which - 1;	// 1-based
this.runtime.trigger(cr.plugins_.Mouse.prototype.cnds.OnRelease, this);
};
instanceProto.onDoubleClick = function(info)
{
info.preventDefault();
this.triggerButton = info.which - 1;	// 1-based
this.triggerType = 1;					// double click
this.runtime.trigger(cr.plugins_.Mouse.prototype.cnds.OnClick, this);
this.runtime.trigger(cr.plugins_.Mouse.prototype.cnds.OnObjectClicked, this);
};
instanceProto.onWheel = function (info)
{
var delta = info.wheelDelta ? info.wheelDelta : info.detail ? -info.detail : 0;
this.triggerDir = (delta < 0 ? 0 : 1);
this.handled = false;
this.runtime.trigger(cr.plugins_.Mouse.prototype.cnds.OnWheel, this);
if (this.handled)
info.preventDefault();
};
pluginProto.cnds = {};
var cnds = pluginProto.cnds;
cnds.OnClick = function (button, type)
{
return button === this.triggerButton && type === this.triggerType;
};
cnds.OnAnyClick = function ()
{
return true;
};
cnds.IsButtonDown = function (button)
{
return this.buttonMap[button + 1];	// jQuery uses 1-based buttons for some reason
};
cnds.OnRelease = function (button)
{
return button === this.triggerButton;
};
cnds.IsOverObject = function (obj)
{
var cnd = this.runtime.getCurrentCondition();
if (cr.is_undefined(cnd.extra.mouseOverInverted))
{
cnd.extra.mouseOverInverted = cnd.inverted;
cnd.inverted = false;
}
var mx = this.mouseXcanvas;
var my = this.mouseYcanvas;
return this.runtime.testAndSelectCanvasPointOverlap(obj, mx, my, cnd.extra.mouseOverInverted);
};
cnds.OnObjectClicked = function (button, type, obj)
{
if (button !== this.triggerButton || type !== this.triggerType)
return false;	// wrong click type
return this.runtime.testAndSelectCanvasPointOverlap(obj, this.mouseXcanvas, this.mouseYcanvas, false);
};
cnds.OnWheel = function (dir)
{
this.handled = true;
return dir === this.triggerDir;
};
pluginProto.acts = {};
var acts = pluginProto.acts;
acts.SetCursor = function (c)
{
var cursor_style = ["auto", "pointer", "text", "crosshair", "move", "help", "wait", "none"][c];
this.runtime.canvas.style.cursor = cursor_style;
if (this.runtime.overlay_canvas)
this.runtime.overlay_canvas.style.cursor = cursor_style;
};
pluginProto.exps = {};
var exps = pluginProto.exps;
exps.X = function (ret, layerparam)
{
var layer, oldScale, oldZoomRate, oldParallaxX, oldAngle;
if (cr.is_undefined(layerparam))
{
layer = this.runtime.getLayerByNumber(0);
oldScale = layer.scale;
oldZoomRate = layer.zoomRate;
oldParallaxX = layer.parallaxX;
oldAngle = layer.angle;
layer.scale = this.runtime.running_layout.scale;
layer.zoomRate = 1.0;
layer.parallaxX = 1.0;
layer.angle = this.runtime.running_layout.angle;
ret.set_float(layer.canvasToLayer(this.mouseXcanvas, this.mouseYcanvas, true));
layer.scale = oldScale;
layer.zoomRate = oldZoomRate;
layer.parallaxX = oldParallaxX;
layer.angle = oldAngle;
}
else
{
if (cr.is_number(layerparam))
layer = this.runtime.getLayerByNumber(layerparam);
else
layer = this.runtime.getLayerByName(layerparam);
if (layer)
ret.set_float(layer.canvasToLayer(this.mouseXcanvas, this.mouseYcanvas, true));
else
ret.set_float(0);
}
};
exps.Y = function (ret, layerparam)
{
var layer, oldScale, oldZoomRate, oldParallaxY, oldAngle;
if (cr.is_undefined(layerparam))
{
layer = this.runtime.getLayerByNumber(0);
oldScale = layer.scale;
oldZoomRate = layer.zoomRate;
oldParallaxY = layer.parallaxY;
oldAngle = layer.angle;
layer.scale = this.runtime.running_layout.scale;
layer.zoomRate = 1.0;
layer.parallaxY = 1.0;
layer.angle = this.runtime.running_layout.angle;
ret.set_float(layer.canvasToLayer(this.mouseXcanvas, this.mouseYcanvas, false));
layer.scale = oldScale;
layer.zoomRate = oldZoomRate;
layer.parallaxY = oldParallaxY;
layer.angle = oldAngle;
}
else
{
if (cr.is_number(layerparam))
layer = this.runtime.getLayerByNumber(layerparam);
else
layer = this.runtime.getLayerByName(layerparam);
if (layer)
ret.set_float(layer.canvasToLayer(this.mouseXcanvas, this.mouseYcanvas, false));
else
ret.set_float(0);
}
};
exps.AbsoluteX = function (ret)
{
ret.set_float(this.mouseXcanvas);
};
exps.AbsoluteY = function (ret)
{
ret.set_float(this.mouseYcanvas);
};
}());
;
;
cr.plugins_.Sprite = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var pluginProto = cr.plugins_.Sprite.prototype;
pluginProto.Type = function(plugin)
{
this.plugin = plugin;
this.runtime = plugin.runtime;
};
var typeProto = pluginProto.Type.prototype;
typeProto.onCreate = function()
{
if (this.is_family)
return;
var i, leni, j, lenj;
var anim, frame;
for (i = 0, leni = this.animations.length; i < leni; i++)
{
anim = this.animations[i];
anim.name = anim[0];
anim.speed = anim[1];
anim.loop = anim[2];
anim.repeatcount = anim[3];
anim.repeatto = anim[4];
anim.pingpong = anim[5];
anim.frames = anim[6];
for (j = 0, lenj = anim.frames.length; j < lenj; j++)
{
frame = anim.frames[j];
frame.texture_file = frame[0];
frame.texture_filesize = frame[1];
frame.duration = frame[2];
frame.hotspotX = frame[3];
frame.hotspotY = frame[4];
frame.image_points = frame[5];
frame.poly_pts = frame[6];
frame.texture_img = new Image();
frame.texture_img.src = frame[0];
frame.texture_img.cr_filesize = frame[1];
frame.webGL_texture = null;
this.runtime.wait_for_textures.push(frame.texture_img);
cr.seal(frame);
}
cr.seal(anim);
}
};
pluginProto.Instance = function(type)
{
this.type = type;
this.runtime = type.runtime;
this.collision_poly = new cr.CollisionPoly(this.type.animations[0].frames[0].poly_pts);
};
var instanceProto = pluginProto.Instance.prototype;
instanceProto.onCreate = function()
{
this.visible = (this.properties[0] === 0);	// 0=visible, 1=invisible
this.compositeOp = cr.effectToCompositeOp(this.properties[2]);
cr.setGLBlend(this, this.properties[2], this.runtime.gl);
this.isTicking = false;
this.inAnimTrigger = false;
if (!(this.type.animations.length === 1 && this.type.animations[0].frames.length === 1) && this.type.animations[0].speed !== 0)
{
this.runtime.tickMe(this);
this.isTicking = true;
}
this.cur_animation = this.type.animations[0];
this.cur_frame = this.properties[1];
if (this.cur_frame < 0)
this.cur_frame = 0;
if (this.cur_frame >= this.cur_animation.frames.length)
this.cur_frame = this.cur_animation.frames.length - 1;
if (this.cur_frame !== 0)
{
var curanimframe = this.cur_animation.frames[this.cur_frame];
this.collision_poly.set_pts(curanimframe.poly_pts);
this.hotspotX = curanimframe.hotspotX;
this.hotspotY = curanimframe.hotspotY;
}
this.cur_anim_speed = this.type.animations[0].speed;
this.frameStart = this.getNowTime();
this.animPlaying = true;
this.animRepeats = 0;
this.animForwards = true;
this.animTriggerName = "";
this.changeAnimName = "";
this.changeAnimFrom = 0;
this.changeAnimFrame = -1;
var i, leni, j, lenj;
var anim, frame;
for (i = 0, leni = this.type.animations.length; i < leni; i++)
{
anim = this.type.animations[i];
for (j = 0, lenj = anim.frames.length; j < lenj; j++)
{
frame = anim.frames[j];
if (this.runtime.glwrap && !frame.webGL_texture)
frame.webGL_texture = this.runtime.glwrap.loadTexture(frame.texture_img, false, this.runtime.linearSampling);
}
}
this.curWebGLTexture = this.cur_animation.frames[this.cur_frame].webGL_texture;
};
instanceProto.animationFinish = function (reverse)
{
this.cur_frame = reverse ? 0 : this.cur_animation.frames.length - 1;
this.animTriggerName = this.cur_animation.name;
this.inAnimTrigger = true;
this.runtime.trigger(cr.plugins_.Sprite.prototype.cnds.OnAnyAnimFinished, this);
this.runtime.trigger(cr.plugins_.Sprite.prototype.cnds.OnAnimFinished, this);
this.inAnimTrigger = false;
if (!this.changeAnimName.length && this.changeAnimFrame === -1)
this.animPlaying = false;
this.animRepeats = 0;
};
instanceProto.getNowTime = function()
{
return (Date.now() - this.runtime.start_time) / 1000.0;
};
instanceProto.tick = function()
{
if (this.changeAnimName.length)
this.doChangeAnim();
if (this.changeAnimFrame >= 0)
this.doChangeAnimFrame();
var now = this.getNowTime();
var cur_animation = this.cur_animation;
var prev_frame = cur_animation.frames[this.cur_frame];
var next_frame;
var cur_frame_time = prev_frame.duration / this.cur_anim_speed;
var cur_timescale = this.runtime.timescale;
if (this.my_timescale !== -1.0)
cur_timescale = this.my_timescale;
cur_frame_time /= (cur_timescale === 0 ? 0.000000001 : cur_timescale);
if (this.animPlaying && now >= this.frameStart + cur_frame_time)
{			
if (this.animForwards)
{
this.cur_frame++;
}
else
{
this.cur_frame--;
}
this.frameStart += cur_frame_time;
if (this.cur_frame >= cur_animation.frames.length)
{
if (cur_animation.pingpong)
{
this.animForwards = false;
this.cur_frame = cur_animation.frames.length - 2;
}
else if (cur_animation.loop)
{
this.cur_frame = cur_animation.repeatto;
}
else
{					
this.animRepeats++;
if (this.animRepeats >= cur_animation.repeatcount)
{
this.animationFinish(false);
}
else
{
this.cur_frame = cur_animation.repeatto;
}
}
}
if (this.cur_frame < 0)
{
if (cur_animation.pingpong)
{
this.cur_frame = 1;
this.animForwards = true;
if (!cur_animation.loop)
{
this.animRepeats++;
if (this.animRepeats >= cur_animation.repeatcount)
{
this.animationFinish(true);
}
}
}
else
{
if (cur_animation.loop)
{
this.cur_frame = cur_animation.repeatto;
}
else
{
this.animRepeats++;
if (this.animRepeats >= cur_animation.repeatcount)
{
this.animationFinish(true);
}
else
{
this.cur_frame = cur_animation.repeatto;
}
}
}
}
if (this.cur_frame < 0)
this.cur_frame = 0;
else if (this.cur_frame >= cur_animation.frames.length)
this.cur_frame = cur_animation.frames.length - 1;
if (now > this.frameStart + ((cur_animation.frames[this.cur_frame].duration / this.cur_anim_speed) / (cur_timescale === 0 ? 0.000000001 : cur_timescale)))
{
this.frameStart = now;
}
next_frame = cur_animation.frames[this.cur_frame];
this.OnFrameChanged(prev_frame, next_frame);
this.runtime.redraw = true;
}
};
instanceProto.doChangeAnim = function ()
{
var prev_frame = this.cur_animation.frames[this.cur_frame];
var i, len, a, anim = null;
for (i = 0, len = this.type.animations.length; i < len; i++)
{
a = this.type.animations[i];
if (a.name.toLowerCase() === this.changeAnimName.toLowerCase())
{
anim = a;
break;
}
}
this.changeAnimName = "";
if (!anim)
return;
if (anim.name.toLowerCase() === this.cur_animation.name.toLowerCase())
return;
this.cur_animation = anim;
this.cur_anim_speed = anim.speed;
if (this.cur_frame < 0)
this.cur_frame = 0;
if (this.cur_frame >= this.cur_animation.frames.length)
this.cur_frame = this.cur_animation.frames.length - 1;
if (this.changeAnimFrom === 1)
this.cur_frame = 0;
this.animPlaying = true;
this.frameStart = this.getNowTime();
this.animForwards = true;
this.OnFrameChanged(prev_frame, this.cur_animation.frames[this.cur_frame]);
this.runtime.redraw = true;
};
instanceProto.doChangeAnimFrame = function ()
{
var prev_frame = this.cur_animation.frames[this.cur_frame];
var prev_frame_number = this.cur_frame;
this.cur_frame = Math.floor(this.changeAnimFrame);
if (this.cur_frame < 0)
this.cur_frame = 0;
if (this.cur_frame >= this.cur_animation.frames.length)
this.cur_frame = this.cur_animation.frames.length - 1;
if (prev_frame_number !== this.cur_frame)
{
this.OnFrameChanged(prev_frame, this.cur_animation.frames[this.cur_frame]);
this.frameStart = this.getNowTime();
this.runtime.redraw = true;
}
this.changeAnimFrame = -1;
};
instanceProto.OnFrameChanged = function (prev_frame, next_frame)
{
var oldw = prev_frame.texture_img.width;
var oldh = prev_frame.texture_img.height;
var neww = next_frame.texture_img.width;
var newh = next_frame.texture_img.height;
if (oldw != neww)
this.width *= (neww / oldw);
if (oldh != newh)
this.height *= (newh / oldh);
this.hotspotX = next_frame.hotspotX;
this.hotspotY = next_frame.hotspotY;
this.collision_poly.set_pts(next_frame.poly_pts);
this.set_bbox_changed();
this.curWebGLTexture = next_frame.webGL_texture;
this.runtime.trigger(cr.plugins_.Sprite.prototype.cnds.OnFrameChanged, this);
};
instanceProto.draw = function(ctx)
{
if (this.opacity !== 1.0)
ctx.globalAlpha = this.opacity;
if (this.compositeOp !== "source-over")
ctx.globalCompositeOperation = this.compositeOp;
var cur_frame = this.cur_animation.frames[this.cur_frame];
var cur_image = cur_frame.texture_img;
var myx;
var myy;
if (this.angle === 0 && this.width >= 0 && this.height >= 0)
{
myx = this.x - (this.hotspotX * this.width);
myy = this.y - (this.hotspotY * this.height);
if (this.runtime.pixel_rounding)
{
myx = Math.round(myx);
myy = Math.round(myy);
}
ctx.drawImage(cur_image,
myx,
myy,
this.width,
this.height);
}
else
{
myx = this.x;
myy = this.y;
if (this.runtime.pixel_rounding)
{
myx = Math.round(myx);
myy = Math.round(myy);
}
ctx.save();
var widthfactor = this.width > 0 ? 1 : -1;
var heightfactor = this.height > 0 ? 1 : -1;
ctx.translate(myx, myy);
ctx.scale(widthfactor, heightfactor);
ctx.rotate(this.angle * widthfactor * heightfactor);
ctx.drawImage(cur_image,
0 - (this.hotspotX * Math.abs(this.width)),
0 - (this.hotspotY * Math.abs(this.height)),
Math.abs(this.width),
Math.abs(this.height));
ctx.restore();
}
if (this.compositeOp !== "source-over")
ctx.globalCompositeOperation = "source-over";
if (this.opacity !== 1.0)
ctx.globalAlpha = 1.0;
/*
ctx.strokeStyle = "#f00";
ctx.lineWidth = 3;
ctx.beginPath();
this.collision_poly.cache_poly(this.width, this.height, this.angle);
var i, len, ax, ay, bx, by;
for (i = 0, len = this.collision_poly.pts_count; i < len; i++)
{
ax = this.collision_poly.pts_cache[i*2] + this.x;
ay = this.collision_poly.pts_cache[i*2+1] + this.y;
bx = this.collision_poly.pts_cache[((i+1)%len)*2] + this.x;
by = this.collision_poly.pts_cache[((i+1)%len)*2+1] + this.y;
ctx.moveTo(ax, ay);
ctx.lineTo(bx, by);
}
ctx.stroke();
ctx.closePath();
*/
/*
if (this.behavior_insts.length >= 1 && this.behavior_insts[0].draw)
{
this.behavior_insts[0].draw(ctx);
}
*/
};
instanceProto.drawGL = function(glw)
{
glw.setBlend(this.srcBlend, this.destBlend);
glw.setTexture(this.curWebGLTexture);
glw.setOpacity(this.opacity);
var q = this.bquad;
if (this.runtime.pixel_rounding)
{
var ox = Math.round(this.x) - this.x;
var oy = Math.round(this.y) - this.y;
glw.quad(q.tlx + ox, q.tly + oy, q.trx + ox, q.try_ + oy, q.brx + ox, q.bry + oy, q.blx + ox, q.bly + oy);
}
else
glw.quad(q.tlx, q.tly, q.trx, q.try_, q.brx, q.bry, q.blx, q.bly);
};
instanceProto.getImagePointIndexByName = function(name_)
{
var cur_frame = this.cur_animation.frames[this.cur_frame];
var i, len;
for (i = 0, len = cur_frame.image_points.length; i < len; i++)
{
if (name_.toLowerCase() === cur_frame.image_points[i][0].toLowerCase())
return i;
}
return -1;
};
instanceProto.getImagePoint = function(imgpt, getX)
{
var cur_frame = this.cur_animation.frames[this.cur_frame];
var image_points = cur_frame.image_points;
var index;
if (cr.is_string(imgpt))
index = this.getImagePointIndexByName(imgpt);
else
index = imgpt - 1;	// 0 is origin
index = Math.floor(index);
if (index < 0 || index >= image_points.length)
return getX ? this.x : this.y;	// return origin
var x = (image_points[index][1] - cur_frame.hotspotX) * this.width;
var y = image_points[index][2];
y = (y - cur_frame.hotspotY) * this.height;
var cosa = Math.cos(this.angle);
var sina = Math.sin(this.angle);
var x_temp = (x * cosa) - (y * sina);
y = (y * cosa) + (x * sina);
x = x_temp;
x += this.x;
y += this.y;
return getX ? x : y;
};
pluginProto.cnds = {};
var cnds = pluginProto.cnds;
function collmemory_add(collmemory, a, b)
{
collmemory.push([a, b]);
};
function collmemory_remove(collmemory, a, b)
{
var i, j = 0, len, entry;
for (i = 0, len = collmemory.length; i < len; i++)
{
entry = collmemory[i];
if (!((entry[0] === a && entry[1] === b) || (entry[0] === b && entry[1] === a)))
{
collmemory[j] = collmemory[i];
j++;
}
}
collmemory.length = j;
};
function collmemory_removeInstance(collmemory, inst)
{
var i, j = 0, len, entry;
for (i = 0, len = collmemory.length; i < len; i++)
{
entry = collmemory[i];
if (entry[0] !== inst && entry[1] !== inst)
{
collmemory[j] = collmemory[i];
j++;
}
}
collmemory.length = j;
};
function collmemory_has(collmemory, a, b)
{
var i, len, entry;
for (i = 0, len = collmemory.length; i < len; i++)
{
entry = collmemory[i];
if ((entry[0] === a && entry[1] === b) || (entry[0] === b && entry[1] === a))
return true;
}
return false;
};
cnds.OnCollision = function (rtype)
{	
if (!rtype)
return false;
var runtime = this.runtime;
var cnd = runtime.getCurrentCondition();
var ltype = cnd.type;
if (!cnd.extra.collmemory)
{
cnd.extra.collmemory = [];
runtime.addDestroyCallback((function (collmemory) {
return function(inst) {
collmemory_removeInstance(collmemory, inst);
};
})(cnd.extra.collmemory));
}
var lsol = ltype.getCurrentSol();
var rsol = rtype.getCurrentSol();
var linstances = lsol.getObjects();
var rinstances = rsol.getObjects();
var l, lenl, linst, r, lenr, rinst;
var curlsol, currsol;
var current_event = runtime.getCurrentEventStack().current_event;
for (l = 0, lenl = linstances.length; l < lenl; l++)
{
linst = linstances[l];
for (r = 0, lenr = rinstances.length; r < lenr; r++)
{
rinst = rinstances[r];
if (runtime.testOverlap(linst, rinst) || runtime.checkRegisteredCollision(linst, rinst))
{
if (!collmemory_has(cnd.extra.collmemory, linst, rinst))
{
collmemory_add(cnd.extra.collmemory, linst, rinst);
runtime.pushCopySol(current_event.solModifiers);
curlsol = ltype.getCurrentSol();
currsol = rtype.getCurrentSol();
curlsol.select_all = false;
currsol.select_all = false;
if (ltype === rtype)
{
curlsol.instances.length = 2;	// just use lsol, is same reference as rsol
curlsol.instances[0] = linst;
curlsol.instances[1] = rinst;
}
else
{
curlsol.instances.length = 1;
currsol.instances.length = 1;
curlsol.instances[0] = linst;
currsol.instances[0] = rinst;
}
current_event.retrigger();
runtime.popSol(current_event.solModifiers);
}
}
else
{
collmemory_remove(cnd.extra.collmemory, linst, rinst);
}
}
}
return false;
};
cnds.IsOverlapping = function (rtype)
{
if (!rtype)
return false;
var runtime = this.runtime;
var cnd = runtime.getCurrentCondition();
var ltype = cnd.type;
var lsol = ltype.getCurrentSol();
var rsol = rtype.getCurrentSol();
var linstances = lsol.getObjects();
var rinstances = rsol.getObjects();
var curlsol, currsol;
var l, lenl, linst, r, lenr, rinst;
var overlapped;
if (cnd.inverted)
{
var ldest = [];
for (l = 0, lenl = linstances.length; l < lenl; l++)
{
linst = linstances[l];
overlapped = false;
for (r = 0, lenr = rinstances.length; r < lenr; r++)
{
rinst = rinstances[r];
if (runtime.testOverlap(linst, rinst))
{
overlapped = true;
break;
}
}
if (!overlapped)
ldest.push(linst);
}
lsol.select_all = false;
lsol.instances = ldest;
return lsol.instances.length;
}
else
{
var current_event = runtime.getCurrentEventStack().current_event;
var temp_arr = [];
for (l = 0, lenl = linstances.length; l < lenl; l++)
{
linst = linstances[l];
for (r = 0, lenr = rinstances.length; r < lenr; r++)
{
rinst = rinstances[r];
if (runtime.testOverlap(linst, rinst))
{
runtime.pushCopySol(current_event.solModifiers);
curlsol = ltype.getCurrentSol();
currsol = rtype.getCurrentSol();
curlsol.select_all = false;
currsol.select_all = false;
if (ltype === rtype)
{
if (collmemory_has(temp_arr, linst, rinst))
{
runtime.popSol(current_event.solModifiers);
continue;
}
else
{
collmemory_add(temp_arr, linst, rinst);	// prevent running for second instance
curlsol.instances.length = 2;
curlsol.instances[0] = linst;
curlsol.instances[1] = rinst;
}
}
else
{
curlsol.instances.length = 1;
currsol.instances.length = 1;
curlsol.instances[0] = linst;
currsol.instances[0] = rinst;
}
current_event.retrigger();
runtime.popSol(current_event.solModifiers);
}
}
}
return false;
}
};
cnds.IsAnimPlaying = function (animname)
{
return this.cur_animation.name.toLowerCase() === animname.toLowerCase();
};
cnds.CompareFrame = function (cmp, framenum)
{
return cr.do_cmp(this.cur_frame, cmp, framenum);
};
cnds.OnAnimFinished = function (animname)
{
return this.animTriggerName.toLowerCase() === animname.toLowerCase();
};
cnds.OnAnyAnimFinished = function ()
{
return true;
};
cnds.OnFrameChanged = function ()
{
return true;
};
cnds.IsMirrored = function ()
{
return this.width < 0;
};
cnds.IsFlipped = function ()
{
return this.height < 0;
};
pluginProto.acts = {};
var acts = pluginProto.acts;
acts.Spawn = function (obj, layer, imgpt)
{
if (!obj || !layer)
return;
var inst = this.runtime.createInstance(obj, layer, this.getImagePoint(imgpt, true), this.getImagePoint(imgpt, false));
inst.angle = this.angle;
inst.set_bbox_changed();
var cur_act = this.runtime.getCurrentAction();
var reset_sol = false;
if (cr.is_undefined(cur_act.extra.Spawn_LastExec) || cur_act.extra.Spawn_LastExec < this.runtime.execcount)
{
reset_sol = true;
cur_act.extra.Spawn_LastExec = this.runtime.execcount;
}
var sol = obj.getCurrentSol();
sol.select_all = false;
if (reset_sol)
{
sol.instances.length = 1;
sol.instances[0] = inst;
}
else
sol.instances.push(inst);
};
acts.SetEffect = function (effect)
{
this.compositeOp = cr.effectToCompositeOp(effect);
cr.setGLBlend(this, effect, this.runtime.gl);
this.runtime.redraw = true;
};
acts.StopAnim = function ()
{
this.animPlaying = false;
};
acts.StartAnim = function (from)
{
this.animPlaying = true;
this.frameStart = this.getNowTime();
if (from === 1 && this.cur_frame !== 0)
{
var prev_frame = this.cur_animation.frames[this.cur_frame];
this.cur_frame = 0;
this.OnFrameChanged(prev_frame, this.cur_animation.frames[0]);
this.runtime.redraw = true;
}
if (!this.isTicking)
{
this.runtime.tickMe(this);
this.isTicking = true;
}
};
acts.SetAnim = function (animname, from)
{
this.changeAnimName = animname;
this.changeAnimFrom = from;
if (!this.isTicking)
{
this.runtime.tickMe(this);
this.isTicking = true;
}
if (!this.inAnimTrigger)
this.doChangeAnim();
};
acts.SetAnimFrame = function (framenumber)
{
this.changeAnimFrame = framenumber;
if (!this.isTicking)
{
this.runtime.tickMe(this);
this.isTicking = true;
}
if (!this.inAnimTrigger)
this.doChangeAnimFrame();
};
acts.SetAnimSpeed = function (s)
{
this.cur_anim_speed = Math.abs(s);
this.animForwards = (s >= 0);
if (!this.isTicking)
{
this.runtime.tickMe(this);
this.isTicking = true;
}
};
acts.SetMirrored = function (m)
{
var neww = Math.abs(this.width) * (m === 0 ? -1 : 1);
if (this.width === neww)
return;
this.width = neww;
this.set_bbox_changed();
};
acts.SetFlipped = function (f)
{
var newh = Math.abs(this.height) * (f === 0 ? -1 : 1);
if (this.height === newh)
return;
this.height = newh;
this.set_bbox_changed();
};
pluginProto.exps = {};
var exps = pluginProto.exps;
exps.AnimationFrame = function (ret)
{
ret.set_int(this.cur_frame);
};
exps.AnimationFrameCount = function (ret)
{
ret.set_int(this.cur_animation.frames.length);
};
exps.AnimationName = function (ret)
{
ret.set_string(this.cur_animation.name);
};
exps.AnimationSpeed = function (ret)
{
ret.set_float(this.cur_anim_speed);
};
exps.ImagePointX = function (ret, imgpt)
{
ret.set_float(this.getImagePoint(imgpt, true));
};
exps.ImagePointY = function (ret, imgpt)
{
ret.set_float(this.getImagePoint(imgpt, false));
};
exps.ImageWidth = function (ret)
{
ret.set_float(this.cur_animation.frames[this.cur_frame].texture_img.width);
};
exps.ImageHeight = function (ret)
{
ret.set_float(this.cur_animation.frames[this.cur_frame].texture_img.height);
};
}());
;
;
cr.plugins_.Text = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var pluginProto = cr.plugins_.Text.prototype;
pluginProto.onCreate = function ()
{
pluginProto.acts.SetWidth = function (w)
{
if (this.width !== w)
{
this.width = w;
this.text_changed = true;	// also recalculate text wrapping
this.set_bbox_changed();
}
};
};
pluginProto.Type = function(plugin)
{
this.plugin = plugin;
this.runtime = plugin.runtime;
};
var typeProto = pluginProto.Type.prototype;
typeProto.onCreate = function()
{
};
pluginProto.Instance = function(type)
{
this.type = type;
this.runtime = type.runtime;
this.lines = [];		// for word wrapping
this.text_changed = true;
};
var instanceProto = pluginProto.Instance.prototype;
var requestedWebFonts = {};		// already requested web fonts have an entry here
instanceProto.onCreate = function()
{
this.text = this.properties[0];
this.visible = (this.properties[1] === 0);	// 0=visible, 1=invisible
this.font = this.properties[2];
this.color = this.properties[3];
this.halign = this.properties[4];			// 0=left, 1=center, 2=right
this.facename = "";
this.fontstyle = "";
var arr = this.font.split(" ");
this.ptSize = 0;
this.textWidth = 0;
this.textHeight = 0;
var i;
for (i = 0; i < arr.length; i++)
{
if (arr[i].substr(arr[i].length - 2, 2) === "pt")
{
this.ptSize = parseInt(arr[i].substr(0, arr[i].length - 2));
this.pxHeight = Math.ceil((this.ptSize / 72.0) * 96.0) + 4;	// assume 96dpi...
this.facename = arr[i + 1];
if (i > 0)
this.fontstyle = arr[i - 1];
break;
}
}
;
};
instanceProto.updateFont = function ()
{
this.font = this.fontstyle + " " + this.ptSize.toString() + "pt " + this.facename;
this.text_changed = true;
this.runtime.redraw = true;
};
instanceProto.draw = function(ctx)
{
ctx.font = this.font;
ctx.textBaseline = "top";
ctx.fillStyle = this.color;
if (this.opacity !== 1.0)
ctx.globalAlpha = this.opacity;
if (this.text_changed)
{
this.type.plugin.WordWrap(this.text, this.lines, ctx, this.width);
this.text_changed = false;
}
this.update_bbox();
var penX = this.bquad.tlx;
var penY = this.bquad.tly;
if (this.runtime.pixel_rounding)
{
penX = Math.round(penX);
penY = Math.round(penY);
}
if (this.angle !== 0)
{
ctx.save();
ctx.translate(penX, penY);
ctx.rotate(this.angle);
penX = 0;
penY = 0;
}
var endY = penY + this.height;
var line_height = this.pxHeight;
var drawX;
var i;
for (i = 0; i < this.lines.length; i++)
{
drawX = penX;
if (this.halign === 1)		// center
drawX = penX + (this.width - this.lines[i].width) / 2;
else if (this.halign === 2)	// right
drawX = penX + (this.width - this.lines[i].width);
ctx.fillText(this.lines[i].text, drawX, penY);
penY += line_height;
if (penY >= endY - line_height)
break;
}
if (this.angle !== 0)
ctx.restore();
if (this.opacity !== 1.0)
ctx.globalAlpha = 1.0;
};
instanceProto.drawGL = function(glw)
{
var oldopacity = this.opacity;
this.opacity *= this.layer.opacity;
if (this.runtime.overlay_ctx)
this.draw(this.runtime.overlay_ctx);
this.opacity = oldopacity;
};
var wordsCache = [];
pluginProto.TokeniseWords = function (text)
{
wordsCache.length = 0;
var cur_word = "";
var ch;
var i = 0;
while (i < text.length)
{
ch = text.charAt(i);
if (ch === "\n")
{
if (cur_word.length)
{
wordsCache.push(cur_word);
cur_word = "";
}
wordsCache.push("\n");
++i;
}
else if (ch === " " || ch === "\t" || ch === "-")
{
do {
cur_word += text.charAt(i);
i++;
}
while (i < text.length && (text.charAt(i) === " " || text.charAt(i) === "\t"));
wordsCache.push(cur_word);
cur_word = "";
}
else if (i < text.length)
{
cur_word += ch;
i++;
}
}
if (cur_word.length)
wordsCache.push(cur_word);
};
pluginProto.WordWrap = function (text, lines, ctx, width)
{
if (!text || !text.length)
{
lines.length = 0;
return;
}
if (width <= 2.0)
{
lines.length = 0;
return;
}
if (text.length <= 100 && text.indexOf("\n") === -1)
{
var all_width = ctx.measureText(text).width;
if (all_width <= width)
{
if (lines.length)
lines.length = 1;
else
lines.push({});
lines[0].text = text;
lines[0].width = all_width;
return;
}
}
this.WordWrapByWord(text, lines, ctx, width);
};
pluginProto.WordWrapByWord = function (text, lines, ctx, width)
{
this.TokeniseWords(text);	// writes to wordsCache
var cur_line = "";
var prev_line;
var line_width;
var i;
var lineIndex = 0;
var line;
for (i = 0; i < wordsCache.length; i++)
{
if (wordsCache[i] === "\n")
{
if (lineIndex >= lines.length)
lines.push({});
line = lines[lineIndex];
line.text = cur_line;
line.width = ctx.measureText(cur_line).width;
lineIndex++;
cur_line = "";
continue;
}
prev_line = cur_line;
cur_line += wordsCache[i];
line_width = ctx.measureText(cur_line).width;
if (line_width >= width)
{
if (lineIndex >= lines.length)
lines.push({});
line = lines[lineIndex];
line.text = prev_line;
line.width = ctx.measureText(prev_line).width;
lineIndex++;
cur_line = wordsCache[i];
}
}
if (cur_line.length)
{
if (lineIndex >= lines.length)
lines.push({});
line = lines[lineIndex];
line.text = cur_line;
line.width = ctx.measureText(cur_line).width;
lineIndex++;
}
lines.length = lineIndex;
};
pluginProto.cnds = {};
var cnds = pluginProto.cnds;
cnds.CompareText = function(text_to_compare, case_sensitive)
{
if (case_sensitive)
return this.text == text_to_compare;
else
return this.text.toLowerCase() == text_to_compare.toLowerCase();
};
pluginProto.acts = {};
var acts = pluginProto.acts;
acts.SetText = function(param)
{
if (cr.is_number(param))
param = Math.round(param * 1e10) / 1e10;	// round to nearest ten billionth - hides floating point errors
var text_to_set = param.toString();
if (this.text !== text_to_set)
{
this.text = text_to_set;
this.text_changed = true;
this.runtime.redraw = true;
}
};
acts.AppendText = function(param)
{
if (cr.is_number(param))
param = Math.round(param * 1e10) / 1e10;	// round to nearest ten billionth - hides floating point errors
var text_to_append = param.toString();
if (text_to_append)	// not empty
{
this.text += text_to_append;
this.text_changed = true;
this.runtime.redraw = true;
}
};
acts.SetFontFace = function (face_, style_)
{
var newstyle = "";
switch (style_) {
case 1: newstyle = "bold"; break;
case 2: newstyle = "italic"; break;
case 3: newstyle = "bold italic"; break;
}
if (face_ === this.facename && newstyle === this.fontstyle)
return;		// no change
this.facename = face_;
this.fontstyle = newstyle;
this.updateFont();
};
acts.SetFontSize = function (size_)
{
if (this.ptSize === size_)
return;
this.ptSize = size_;
this.pxHeight = Math.ceil((this.ptSize / 72.0) * 96.0) + 4;	// assume 96dpi...
this.updateFont();
};
acts.SetFontColor = function (rgb)
{
var newcolor = "rgb(" + cr.GetRValue(rgb).toString() + "," + cr.GetGValue(rgb).toString() + "," + cr.GetBValue(rgb).toString() + ")";
if (newcolor === this.color)
return;
this.color = newcolor;
this.runtime.redraw = true;
};
acts.SetWebFont = function (familyname_, cssurl_)
{
if (requestedWebFonts.hasOwnProperty(cssurl_))
{
var newfacename = "'" + familyname_ + "'";
if (this.facename === newfacename)
return;	// no change
this.facename = newfacename;
this.updateFont();
return;
}
var wf = document.createElement("link");
wf.href = cssurl_;
wf.rel = "stylesheet";
wf.type = "text/css";
var refreshFunc = (function (self) {
return function () {
self.runtime.redraw = true;
self.text_changed = true;
}
})(this);
wf.onload = refreshFunc;
for (var i = 1; i < 10; i++)
{
setTimeout(refreshFunc, i * 100);
setTimeout(refreshFunc, i * 1000);
}
document.getElementsByTagName('head')[0].appendChild(wf);
requestedWebFonts[cssurl_] = true;
this.facename = "'" + familyname_ + "'";
this.updateFont();
;
};
pluginProto.exps = {};
var exps = pluginProto.exps;
exps.Text = function(ret)
{
ret.set_string(this.text);
};
exps.FaceName = function (ret)
{
ret.set_string(this.facename);
};
exps.FaceSize = function (ret)
{
ret.set_int(this.ptSize);
};
exps.TextWidth = function (ret)
{
var w = 0;
var i, len, x;
for (i = 0, len = this.lines.length; i < len; i++)
{
x = this.lines[i].width;
if (w < x)
w = x;
}
ret.set_int(w);
};
exps.TextHeight = function (ret)
{
ret.set_int(this.lines.length * this.pxHeight);
};
}());
;
;
cr.plugins_.TiledBg = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var pluginProto = cr.plugins_.TiledBg.prototype;
pluginProto.Type = function(plugin)
{
this.plugin = plugin;
this.runtime = plugin.runtime;
};
var typeProto = pluginProto.Type.prototype;
typeProto.onCreate = function()
{
if (this.is_family)
return;
this.texture_img = new Image();
this.texture_img.src = this.texture_file;
this.texture_img.cr_filesize = this.texture_filesize;
this.runtime.wait_for_textures.push(this.texture_img);
this.pattern = null;
this.webGL_texture = null;
};
pluginProto.Instance = function(type)
{
this.type = type;
this.runtime = type.runtime;
};
var instanceProto = pluginProto.Instance.prototype;
instanceProto.onCreate = function()
{
this.visible = (this.properties[0] === 0);							// 0=visible, 1=invisible
this.compositeOp = cr.effectToCompositeOp(this.properties[1]);
cr.setGLBlend(this, this.properties[1], this.runtime.gl);
this.rcTex = new cr.rect(0, 0, 0, 0);
if (this.runtime.glwrap && !this.type.webGL_texture)
this.type.webGL_texture = this.runtime.glwrap.loadTexture(this.type.texture_img, true, this.runtime.linearSampling);
};
instanceProto.draw = function(ctx)
{
if (!this.type.pattern)
this.type.pattern = ctx.createPattern(this.type.texture_img, "repeat");
ctx.save();
ctx.globalAlpha = this.opacity;
ctx.globalCompositeOperation = this.compositeOp;
ctx.fillStyle = this.type.pattern;
var myx = this.x;
var myy = this.y;
if (this.runtime.pixel_rounding)
{
myx = Math.round(myx);
myy = Math.round(myy);
}
var drawX = -(this.hotspotX * this.width);
var drawY = -(this.hotspotY * this.height);
var offX = drawX % this.type.texture_img.width;
var offY = drawY % this.type.texture_img.height;
if (offX < 0)
offX += this.type.texture_img.width;
if (offY < 0)
offY += this.type.texture_img.height;
ctx.translate(myx, myy);
ctx.rotate(this.angle);
ctx.translate(offX, offY);
ctx.fillRect(drawX - offX,
drawY - offY,
this.width,
this.height);
ctx.restore();
};
instanceProto.drawGL = function(glw)
{
glw.setBlend(this.srcBlend, this.destBlend);
glw.setTexture(this.type.webGL_texture);
glw.setOpacity(this.opacity);
var rcTex = this.rcTex;
rcTex.right = this.width / this.type.texture_img.width;
rcTex.bottom = this.height / this.type.texture_img.height;
var q = this.bquad;
if (this.runtime.pixel_rounding)
{
var ox = Math.round(this.x) - this.x;
var oy = Math.round(this.y) - this.y;
glw.quadTex(q.tlx + ox, q.tly + oy, q.trx + ox, q.try_ + oy, q.brx + ox, q.bry + oy, q.blx + ox, q.bly + oy, rcTex);
}
else
glw.quadTex(q.tlx, q.tly, q.trx, q.try_, q.brx, q.bry, q.blx, q.bly, rcTex);
};
pluginProto.cnds = {};
var cnds = pluginProto.cnds;
pluginProto.acts = {};
var acts = pluginProto.acts;
acts.SetEffect = function (effect)
{	
this.compositeOp = cr.effectToCompositeOp(effect);
cr.setGLBlend(this, effect, this.runtime.gl);
this.runtime.redraw = true;
};
pluginProto.exps = {};
var exps = pluginProto.exps;
}());
;
;
cr.behaviors.Bullet = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var behaviorProto = cr.behaviors.Bullet.prototype;
behaviorProto.Type = function(behavior, objtype)
{
this.behavior = behavior;
this.objtype = objtype;
this.runtime = behavior.runtime;
};
var behtypeProto = behaviorProto.Type.prototype;
behtypeProto.onCreate = function()
{
};
behaviorProto.Instance = function(type, inst)
{
this.type = type;
this.behavior = type.behavior;
this.inst = inst;				// associated object instance to modify
this.runtime = type.runtime;
};
var behinstProto = behaviorProto.Instance.prototype;
behinstProto.onCreate = function()
{
var speed = this.properties[0];
this.acc = this.properties[1];
this.g = this.properties[2];
this.bounceOffSolid = (this.properties[3] !== 0);
this.setAngle = (this.properties[4] !== 0);
this.dx = Math.cos(this.inst.angle) * speed;
this.dy = Math.sin(this.inst.angle) * speed;
this.lastx = this.inst.x;
this.lasty = this.inst.y;		
this.lastKnownAngle = this.inst.angle;
this.enabled = true;
};
behinstProto.tick = function ()
{
if (!this.enabled)
return;
var dt = this.runtime.getDt(this.inst);
var s, a;
var bounceSolid, bounceAngle;
if (this.inst.angle !== this.lastKnownAngle)
{
s = cr.distanceTo(0, 0, this.dx, this.dy);
this.dx = Math.cos(this.inst.angle) * s;
this.dy = Math.sin(this.inst.angle) * s;
this.lastKnownAngle = this.inst.angle;
}
if (this.acc !== 0)
{
s = cr.distanceTo(0, 0, this.dx, this.dy);
if (this.dx === 0 && this.dy === 0)
a = this.inst.angle;
else
a = cr.angleTo(0, 0, this.dx, this.dy);
s += this.acc * dt;
if (s < 0)
s = 0;
this.dx = Math.cos(a) * s;
this.dy = Math.sin(a) * s;
}
if (this.g !== 0)
this.dy += this.g * dt;
this.lastx = this.inst.x;
this.lasty = this.inst.y;
if (this.dx !== 0 || this.dy !== 0)
{
this.inst.x += this.dx * dt;
this.inst.y += this.dy * dt;
if (this.setAngle)
{
this.inst.angle = cr.angleTo(0, 0, this.dx, this.dy);
this.inst.set_bbox_changed();
this.lastKnownAngle = this.inst.angle;
}
this.inst.set_bbox_changed();
if (this.bounceOffSolid)
{
bounceSolid = this.runtime.testOverlapSolid(this.inst);
if (bounceSolid)
{
this.runtime.registerCollision(this.inst, bounceSolid);
s = cr.distanceTo(0, 0, this.dx, this.dy);
bounceAngle = this.runtime.calculateSolidBounceAngle(this.inst, this.lastx, this.lasty);
this.dx = Math.cos(bounceAngle) * s;
this.dy = Math.sin(bounceAngle) * s;
this.inst.x += this.dx * dt;			// move out for one tick since the object can't have spent a tick in the solid
this.inst.y += this.dy * dt;
this.inst.set_bbox_changed();
if (this.setAngle)
{
this.inst.angle = bounceAngle;
this.lastKnownAngle = bounceAngle;
this.inst.set_bbox_changed();
}
if (!this.runtime.pushOutSolid(this.inst, this.dx / s, this.dy / s, Math.max(s * 2.5 * dt, 30)))
this.runtime.pushOutSolidNearest(this.inst, 100);
}
}
}
};
behaviorProto.cnds = {};
var cnds = behaviorProto.cnds;
cnds.CompareSpeed = function (cmp, s)
{
return cr.do_cmp(cr.distanceTo(0, 0, this.dx, this.dy), cmp, s);
};
behaviorProto.acts = {};
var acts = behaviorProto.acts;
acts.SetSpeed = function (s)
{
if (s < 0)
s = 0;
var a = cr.angleTo(0, 0, this.dx, this.dy);
this.dx = Math.cos(a) * s;
this.dy = Math.sin(a) * s;
};
acts.SetAcceleration = function (a)
{
this.acc = a;
};
acts.SetGravity = function (g)
{
this.g = g;
};
acts.SetAngleOfMotion = function (a)
{
a = cr.to_radians(a);
var s = cr.distanceTo(0, 0, this.dx, this.dy)
this.dx = Math.cos(a) * s;
this.dy = Math.sin(a) * s;
};
acts.Bounce = function (objtype)
{
if (!objtype)
return;
var otherinst = objtype.getFirstPicked();
if (!otherinst)
return;
var dt = this.runtime.getDt(this.inst);
var s = cr.distanceTo(0, 0, this.dx, this.dy);
var bounceAngle = this.runtime.calculateSolidBounceAngle(this.inst, this.lastx, this.lasty, otherinst);
this.dx = Math.cos(bounceAngle) * s;
this.dy = Math.sin(bounceAngle) * s;
this.inst.x += this.dx * dt;			// move out for one tick since the object can't have spent a tick in the solid
this.inst.y += this.dy * dt;
this.inst.set_bbox_changed();
if (this.setAngle)
{
this.inst.angle = bounceAngle;
this.lastKnownAngle = bounceAngle;
this.inst.set_bbox_changed();
}
if (!this.runtime.pushOutSolid(this.inst, this.dx / s, this.dy / s, Math.max(s * 2.5 * dt, 30)))
this.runtime.pushOutSolidNearest(this.inst, 100);
};
acts.SetEnabled = function (en)
{
this.enabled = (en === 1);
};
behaviorProto.exps = {};
var exps = behaviorProto.exps;
exps.Speed = function (ret)
{
var s = cr.distanceTo(0, 0, this.dx, this.dy);
s = cr.round6dp(s);
ret.set_float(s);
};
exps.Acceleration = function (ret)
{
ret.set_float(this.acc);
};
exps.AngleOfMotion = function (ret)
{
ret.set_float(cr.to_degrees(cr.angleTo(0, 0, this.dx, this.dy)));
};
}());
;
;
cr.behaviors.Platform = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var behaviorProto = cr.behaviors.Platform.prototype;
behaviorProto.Type = function(behavior, objtype)
{
this.behavior = behavior;
this.objtype = objtype;
this.runtime = behavior.runtime;
};
var behtypeProto = behaviorProto.Type.prototype;
behtypeProto.onCreate = function()
{
};
var ANIMMODE_STOPPED = 0;
var ANIMMODE_MOVING = 1;
var ANIMMODE_JUMPING = 2;
var ANIMMODE_FALLING = 3;
behaviorProto.Instance = function(type, inst)
{
this.type = type;
this.behavior = type.behavior;
this.inst = inst;				// associated object instance to modify
this.runtime = type.runtime;
this.leftkey = false;
this.rightkey = false;
this.jumpkey = false;
this.jumped = false;		// prevent bunnyhopping
this.ignoreInput = false;
this.simleft = false;
this.simright = false;
this.simjump = false;
this.lastFloorObject = null;
this.lastFloorX = 0;
this.lastFloorY = 0;
this.animMode = ANIMMODE_STOPPED;
this.enabled = true;
this.dx = 0;
this.dy = 0;
};
var behinstProto = behaviorProto.Instance.prototype;
behinstProto.updateGravity = function()
{
this.downx = Math.cos(this.ga);
this.downy = Math.sin(this.ga);
this.rightx = Math.cos(this.ga - Math.PI / 2);
this.righty = Math.sin(this.ga - Math.PI / 2);
this.downx = cr.round6dp(this.downx);
this.downy = cr.round6dp(this.downy);
this.rightx = cr.round6dp(this.rightx);
this.righty = cr.round6dp(this.righty);
if (this.g < 0)
{
this.downx *= -1;
this.downy *= -1;
this.g = Math.abs(this.g);
}
};
behinstProto.onCreate = function()
{
this.maxspeed = this.properties[0];
this.acc = this.properties[1];
this.dec = this.properties[2];
this.jumpStrength = this.properties[3];
this.g = this.properties[4];
this.maxFall = this.properties[5];
this.defaultControls = (this.properties[6] === 1);	// 0=no, 1=yes
this.ga = cr.to_radians(90);
this.updateGravity();
if (this.defaultControls)
{
jQuery(document).keydown(
(function (self) {
return function(info) {
self.onKeyDown(info);
};
})(this)
);
jQuery(document).keyup(
(function (self) {
return function(info) {
self.onKeyUp(info);
};
})(this)
);
}
this.myDestroyCallback = (function (self) {
return function(inst) {
self.onInstanceDestroyed(inst);
};
})(this);
this.runtime.addDestroyCallback(this.myDestroyCallback);
};
behinstProto.onInstanceDestroyed = function (inst)
{
if (this.lastFloorObject == inst)
this.lastFloorObject = null;
};
behinstProto.onDestroy = function ()
{
this.lastFloorObject = null;
this.runtime.removeDestroyCallback(this.myDestroyCallback);
};
behinstProto.onKeyDown = function (info)
{	
switch (info.which) {
case 38:	// up
info.preventDefault();
this.jumpkey = true;
break;
case 37:	// left
info.preventDefault();
this.leftkey = true;
break;
case 39:	// right
info.preventDefault();
this.rightkey = true;
break;
}
};
behinstProto.onKeyUp = function (info)
{
switch (info.which) {
case 38:	// up
info.preventDefault();
this.jumpkey = false;
this.jumped = false;
break;
case 37:	// left
info.preventDefault();
this.leftkey = false;
break;
case 39:	// right
info.preventDefault();
this.rightkey = false;
break;
}
};
behinstProto.getGDir = function ()
{
if (this.g < 0)
return -1;
else
return 1;
};
behinstProto.isOnFloor = function ()
{
var ret = null;
var ret2 = null;
var i, len, j;
var oldx = this.inst.x;
var oldy = this.inst.y;
this.inst.x += this.downx;
this.inst.y += this.downy;
this.inst.set_bbox_changed();
if (this.lastFloorObject && this.runtime.testOverlap(this.inst, this.lastFloorObject))
{
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
return this.lastFloorObject;
}
else
{
ret = this.runtime.testOverlapSolid(this.inst);
if (!ret)
ret2 = this.runtime.testOverlapJumpThru(this.inst, true);
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
if (ret)		// was overlapping solid
{
if (this.runtime.testOverlap(this.inst, ret))
return null;
else
return ret;
}
if (ret2 && ret2.length)
{
for (i = 0, j = 0, len = ret2.length; i < len; i++)
{
ret2[j] = ret2[i];
if (!this.runtime.testOverlap(this.inst, ret2[i]))
j++;
}
if (j >= 1)
return ret2[0];
}
return null;
}
};
behinstProto.tick = function ()
{
var dt = this.runtime.getDt(this.inst);
var mx, my, obstacle, mag, allover, i, len, j;
if (!this.jumpkey && !this.simjump)
this.jumped = false;
var left = this.leftkey || this.simleft;
var right = this.rightkey || this.simright;
var jump = (this.jumpkey || this.simjump) && !this.jumped;
this.simleft = false;
this.simright = false;
this.simjump = false;
if (!this.enabled)
return;
this.inst.x -= this.downx;
this.inst.y -= this.downy;
this.inst.set_bbox_changed();
if (this.ignoreInput)
{
left = false;
right = false;
jump = false;
}
var floor_ = this.isOnFloor();
var lastFloor = this.lastFloorObject;
var collobj = this.runtime.testOverlapSolid(this.inst);
if (collobj)
{
if (this.runtime.pushOutSolidNearest(this.inst, Math.max(this.inst.width, this.inst.height) / 2))
this.runtime.registerCollision(this.inst, collobj);
else
{
this.inst.x += this.downx;
this.inst.y += this.downy;
this.inst.set_bbox_changed();
return;
}
}
if (floor_)
{
if (this.dy > 0)
this.dy = 0;
if (lastFloor != floor_)
{
this.lastFloorObject = floor_;
this.lastFloorX = floor_.x;
this.lastFloorY = floor_.y;
this.runtime.registerCollision(this.inst, floor_);
}
else if (floor_.x !== this.lastFloorX || floor_.y !== this.lastFloorY)
{
mx = (floor_.x - this.lastFloorX);
my = (floor_.y - this.lastFloorY);
this.inst.x += mx;
this.inst.y += my;
this.inst.set_bbox_changed();
this.lastFloorX = floor_.x;
this.lastFloorY = floor_.y;
collobj = this.runtime.testOverlapSolid(this.inst);
if (collobj)
{
this.runtime.registerCollision(this.inst, collobj);
if (mx !== 0)
{
if (mx > 0)
this.runtime.pushOutSolid(this.inst, -this.rightx, -this.righty);
else
this.runtime.pushOutSolid(this.inst, this.rightx, this.righty);
}
this.runtime.pushOutSolid(this.inst, -this.downx, -this.downy);
}
}
if (jump)
{
this.runtime.trigger(cr.behaviors.Platform.prototype.cnds.OnJump, this.inst);
this.animMode = ANIMMODE_JUMPING;
this.dy = -this.jumpStrength;
this.jumped = true;
}
}
else
{
this.lastFloorObject = null;
this.dy += this.g * dt;
if (this.dy > this.maxFall)
this.dy = this.maxFall;
if (jump)
this.jumped = true;
}
if (left == right)	// both up or both down
{
if (this.dx < 0)
{
this.dx += this.dec * dt;
if (this.dx > 0)
this.dx = 0;
}
else if (this.dx > 0)
{
this.dx -= this.dec * dt;
if (this.dx < 0)
this.dx = 0;
}
}
if (left && !right)
{
if (this.dx > 0)
this.dx -= (this.acc + this.dec) * dt;
else
this.dx -= this.acc * dt;
}
if (right && !left)
{
if (this.dx < 0)
this.dx += (this.acc + this.dec) * dt;
else
this.dx += this.acc * dt;
}
if (this.dx > this.maxspeed)
this.dx = this.maxspeed;
else if (this.dx < -this.maxspeed)
this.dx = -this.maxspeed;
if (this.dx !== 0)
{		
var oldx = this.inst.x;
var oldy = this.inst.y;
mx = this.dx * dt * this.rightx;
my = this.dx * dt * this.righty;
this.inst.x += this.rightx * (this.dx > 1 ? 1 : -1) - this.downx;
this.inst.y += this.righty * (this.dx > 1 ? 1 : -1) - this.downy;
this.inst.set_bbox_changed();
var is_jumpthru = false;
var slope_too_steep = this.runtime.testOverlapSolid(this.inst);
/*
if (!slope_too_steep && floor_)
{
slope_too_steep = this.runtime.testOverlapJumpThru(this.inst);
is_jumpthru = true;
if (slope_too_steep)
{
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
if (this.runtime.testOverlap(this.inst, slope_too_steep))
{
slope_too_steep = null;
is_jumpthru = false;
}
}
}
*/
this.inst.x = oldx + mx;
this.inst.y = oldy + my;
this.inst.set_bbox_changed();
obstacle = this.runtime.testOverlapSolid(this.inst);
if (!obstacle && floor_)
{
obstacle = this.runtime.testOverlapJumpThru(this.inst);
if (obstacle)
{
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
if (this.runtime.testOverlap(this.inst, obstacle))
{
obstacle = null;
is_jumpthru = false;
}
else
is_jumpthru = true;
this.inst.x = oldx + mx;
this.inst.y = oldy + my;
this.inst.set_bbox_changed();
}
}
if (obstacle)
{
var push_dist = Math.abs(this.dx * dt) + 2;
if (slope_too_steep || !this.runtime.pushOutSolid(this.inst, -this.downx, -this.downy, push_dist, is_jumpthru))
{
this.runtime.registerCollision(this.inst, obstacle);
push_dist = Math.max(Math.abs(this.dx * dt * 2.5), 30);
if (!this.runtime.pushOutSolid(this.inst, this.rightx * (this.dx < 0 ? 1 : -1), this.righty * (this.dx < 0 ? 1 : -1), push_dist, false))
{
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
}
else if (Math.abs(this.inst.x - oldx) < 1)
{
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
}
if (!is_jumpthru)
this.dx = 0;	// stop
}
}
else if (floor_ && !this.isOnFloor())
{
mag = Math.ceil(Math.abs(this.dx * dt)) + 2;
oldx = this.inst.x;
oldy = this.inst.y;
this.inst.x += this.downx * mag;
this.inst.y += this.downy * mag;
this.inst.set_bbox_changed();
if (this.runtime.testOverlapSolid(this.inst) || this.runtime.testOverlapJumpThru(this.inst))
this.runtime.pushOutSolid(this.inst, -this.downx, -this.downy, mag + 2, true);
else
{
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
}
}
}
if (this.dy !== 0)
{
var oldx = this.inst.x;
var oldy = this.inst.y;
this.inst.x += this.dy * dt * this.downx;
this.inst.y += this.dy * dt * this.downy;
var newx = this.inst.x;
var newy = this.inst.y;
this.inst.set_bbox_changed();
collobj = this.runtime.testOverlapSolid(this.inst);
var fell_on_jumpthru = false;
if (!collobj && (this.dy > 0) && !floor_)
{
allover = this.runtime.testOverlapJumpThru(this.inst, true);
if (allover && allover.length)
{
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
for (i = 0, j = 0, len = allover.length; i < len; i++)
{
allover[j] = allover[i];
if (!this.runtime.testOverlap(this.inst, allover[i]))
j++;
}
allover.length = j;
this.inst.x = newx;
this.inst.y = newy;
this.inst.set_bbox_changed();
if (allover.length >= 1)
collobj = allover[0];
}
fell_on_jumpthru = !!collobj;
}
if (collobj)
{
this.runtime.registerCollision(this.inst, collobj);
var push_dist = fell_on_jumpthru ? (this.dy * dt + 1) : Math.max(Math.abs(this.dy * dt * 2.5), 30);
if (!this.runtime.pushOutSolid(this.inst, this.downx * (this.dy < 0 ? 1 : -1), this.downy * (this.dy < 0 ? 1 : -1), push_dist, fell_on_jumpthru))
{
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
}
this.dy = 0;	// stop
}
}
this.inst.x += this.downx;
this.inst.y += this.downy;
this.inst.set_bbox_changed();
if (this.animMode !== ANIMMODE_FALLING && this.dy > 0 && !floor_)
{
this.runtime.trigger(cr.behaviors.Platform.prototype.cnds.OnFall, this.inst);
this.animMode = ANIMMODE_FALLING;
}
if (floor_)
{
if (this.animMode === ANIMMODE_FALLING || (jump && this.dy === 0))
{
this.runtime.trigger(cr.behaviors.Platform.prototype.cnds.OnLand, this.inst);
if (this.dx === 0 && this.dy === 0)
this.animMode = ANIMMODE_STOPPED;
else
this.animMode = ANIMMODE_MOVING;
}
else
{
if (this.animMode !== ANIMMODE_STOPPED && this.dx === 0 && this.dy === 0)
{
this.runtime.trigger(cr.behaviors.Platform.prototype.cnds.OnStop, this.inst);
this.animMode = ANIMMODE_STOPPED;
}
if (this.animMode !== ANIMMODE_MOVING && (this.dx !== 0 || this.dy !== 0) && !jump)
{
this.runtime.trigger(cr.behaviors.Platform.prototype.cnds.OnMove, this.inst);
this.animMode = ANIMMODE_MOVING;
}
}
}
};
behaviorProto.cnds = {};
var cnds = behaviorProto.cnds;
cnds.IsMoving = function ()
{
return this.dx !== 0 || this.dy !== 0;
};
cnds.CompareSpeed = function (cmp, s)
{
var speed = Math.sqrt(this.dx * this.dx + this.dy * this.dy);
return cr.do_cmp(speed, cmp, s);
};
cnds.IsOnFloor = function ()
{
if (this.dy !== 0)
return false;
var overlapSolid = this.runtime.testOverlapSolid(this.inst);
var overlapJumpThru = null;
var i, len, j;
if (!overlapSolid)
{
overlapJumpThru = this.runtime.testOverlapJumpThru(this.inst, true);
if (!overlapJumpThru || !overlapJumpThru.length)
return false;
}
var ret = false;
var oldx = this.inst.x;
var oldy = this.inst.y;
this.inst.x -= this.downx;
this.inst.y -= this.downy;
this.inst.set_bbox_changed();
if (overlapSolid)
{
ret = !this.runtime.testOverlapSolid(this.inst);
}
else
{
for (i = 0, j = 0, len = overlapJumpThru.length; i < len; i++)
{
overlapJumpThru[j] = overlapJumpThru[i];
if (!this.runtime.testOverlap(this.inst, overlapJumpThru[i]))
j++;
}
if (j >= 1)
ret = true;
}
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
return ret;
};
cnds.IsByWall = function (side)
{
var ret = false;
var oldx = this.inst.x;
var oldy = this.inst.y;
this.inst.x -= this.downx * 3;
this.inst.y -= this.downy * 3;
this.inst.set_bbox_changed();
if (this.runtime.testOverlapSolid(this.inst))
{
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
return false;
}
if (side === 0)		// left
{
this.inst.x -= this.rightx * 2;
this.inst.y -= this.righty * 2;
}
else
{
this.inst.x += this.rightx * 2;
this.inst.y += this.righty * 2;
}
this.inst.set_bbox_changed();
ret = this.runtime.testOverlapSolid(this.inst);
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
return ret;
};
cnds.IsJumping = function ()
{
return this.dy < 0;
};
cnds.IsFalling = function ()
{
return this.dy > 0;
};
cnds.OnJump = function ()
{
return true;
};
cnds.OnFall = function ()
{
return true;
};
cnds.OnStop = function ()
{
return true;
};
cnds.OnMove = function ()
{
return true;
};
cnds.OnLand = function ()
{
return true;
};
behaviorProto.acts = {};
var acts = behaviorProto.acts;
acts.SetIgnoreInput = function (ignoring)
{
this.ignoreInput = ignoring;
};
acts.SetMaxSpeed = function (maxspeed)
{
this.maxspeed = maxspeed;
if (this.maxspeed < 0)
this.maxspeed = 0;
};
acts.SetAcceleration = function (acc)
{
this.acc = acc;
if (this.acc < 0)
this.acc = 0;
};
acts.SetDeceleration = function (dec)
{
this.dec = dec;
if (this.dec < 0)
this.dec = 0;
};
acts.SetJumpStrength = function (js)
{
this.jumpStrength = js;
if (this.jumpStrength < 0)
this.jumpStrength = 0;
};
acts.SetGravity = function (grav)
{
if (grav === this.g)
return;		// no change
this.g = grav;
this.updateGravity();
this.lastFloorObject = null;
};
acts.SetMaxFallSpeed = function (mfs)
{
this.maxFall = mfs;
if (this.maxFall < 0)
this.maxFall = 0;
};
acts.SimulateControl = function (ctrl)
{
switch (ctrl) {
case 0:		this.simleft = true;	break;
case 1:		this.simright = true;	break;
case 2:		this.simjump = true;	break;
}
};
acts.SetVectorX = function (vx)
{
this.dx = vx;
};
acts.SetVectorY = function (vy)
{
this.dy = vy;
};
acts.SetGravityAngle = function (a)
{
a = cr.to_radians(a);
a = cr.clamp_angle(a);
if (this.ga === a)
return;		// no change
this.ga = a;
this.updateGravity();
this.lastFloorObject = null;
};
acts.SetEnabled = function (en)
{
this.enabled = (en === 1);
};
behaviorProto.exps = {};
var exps = behaviorProto.exps;
exps.Speed = function (ret)
{
ret.set_float(Math.sqrt(this.dx * this.dx + this.dy * this.dy));
};
exps.MaxSpeed = function (ret)
{
ret.set_float(this.maxspeed);
};
exps.Acceleration = function (ret)
{
ret.set_float(this.acc);
};
exps.Deceleration = function (ret)
{
ret.set_float(this.dec);
};
exps.JumpStrength = function (ret)
{
ret.set_float(this.jumpStrength);
};
exps.Gravity = function (ret)
{
ret.set_float(this.g);
};
exps.MaxFallSpeed = function (ret)
{
ret.set_float(this.maxFall);
};
exps.MovingAngle = function (ret)
{
ret.set_float(cr.to_degrees(Math.atan2(this.dy, this.dx)));
};
exps.VectorX = function (ret)
{
ret.set_float(this.dx);
};
exps.VectorY = function (ret)
{
ret.set_float(this.dy);
};
}());
;
;
cr.behaviors.destroy = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var behaviorProto = cr.behaviors.destroy.prototype;
behaviorProto.Type = function(behavior, objtype)
{
this.behavior = behavior;
this.objtype = objtype;
this.runtime = behavior.runtime;
};
var behtypeProto = behaviorProto.Type.prototype;
behtypeProto.onCreate = function()
{
};
behaviorProto.Instance = function(type, inst)
{
this.type = type;
this.behavior = type.behavior;
this.inst = inst;				// associated object instance to modify
this.runtime = type.runtime;
};
var behinstProto = behaviorProto.Instance.prototype;
behinstProto.onCreate = function()
{
};
behinstProto.tick = function ()
{
this.inst.update_bbox();
var bbox = this.inst.bbox;
var layout = this.inst.layer.layout;
if (bbox.right < 0 || bbox.bottom < 0 || bbox.left > layout.width || bbox.top > layout.height)
this.runtime.DestroyInstance(this.inst);
};
}());
;
;
cr.behaviors.solid = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var behaviorProto = cr.behaviors.solid.prototype;
behaviorProto.Type = function(behavior, objtype)
{
this.behavior = behavior;
this.objtype = objtype;
this.runtime = behavior.runtime;
};
var behtypeProto = behaviorProto.Type.prototype;
behtypeProto.onCreate = function()
{
};
behaviorProto.Instance = function(type, inst)
{
this.type = type;
this.behavior = type.behavior;
this.inst = inst;				// associated object instance to modify
this.runtime = type.runtime;
this.inst.extra.solidEnabled = true;
};
var behinstProto = behaviorProto.Instance.prototype;
behinstProto.onCreate = function()
{
};
behinstProto.tick = function ()
{
};
behaviorProto.acts = {};
var acts = behaviorProto.acts;
acts.SetEnabled = function (e)
{
this.inst.extra.solidEnabled = !!e;
};
}());
cr.getProjectModel = function() { return [
null,
"Game",
[
[
cr.plugins_.Mouse,
true,
false,
false,
false,
false,
false,
false
]
,	[
cr.plugins_.Sprite,
false,
true,
true,
true,
true,
true,
true
]
,	[
cr.plugins_.Text,
false,
true,
true,
true,
true,
true,
true
]
,	[
cr.plugins_.TiledBg,
false,
true,
true,
true,
true,
true,
true
]
],
[
[
"t0",
cr.plugins_.TiledBg,
false,
0,
["images/earth.png", 612],
null,
[
[
"Solid",
cr.behaviors.solid
]
],
false
]
,	[
"t1",
cr.plugins_.Sprite,
false,
2,
null,
[
[
"move",
15,
true,
1,
0,
false,
[
["images/player-move-000.png", 812, 1, 0.5, 0.5,[],[]],
["images/player-move-001.png", 763, 1, 0.5, 0.5,[],[]],
["images/player-move-002.png", 818, 1, 0.5, 0.5,[],[]],
["images/player-move-003.png", 779, 1, 0.5, 0.5,[],[]],
["images/player-move-004.png", 785, 1, 0.5, 0.5,[],[]],
["images/player-move-005.png", 770, 1, 0.5, 0.5,[],[]],
["images/player-move-006.png", 811, 1, 0.5, 0.5,[],[]],
["images/player-move-007.png", 783, 1, 0.5, 0.5,[],[]]
]
]
,			[
"jump",
5,
false,
1,
0,
false,
[
["images/player-jump-000.png", 816, 1, 0.5, 0.5,[],[]]
]
]
,			[
"fly",
15,
true,
1,
0,
false,
[
["images/player-fly-000.png", 503, 1, 0.5, 0.5,[],[]],
["images/player-fly-001.png", 482, 1, 0.5, 0.5,[],[]],
["images/player-fly-002.png", 495, 1, 0.5, 0.5,[],[]],
["images/player-fly-003.png", 502, 1, 0.5, 0.5,[],[]],
["images/player-fly-004.png", 501, 1, 0.5, 0.5,[],[]],
["images/player-fly-005.png", 501, 1, 0.5, 0.5,[],[]],
["images/player-fly-006.png", 502, 1, 0.5, 0.5,[],[]],
["images/player-fly-007.png", 495, 1, 0.5, 0.5,[],[]],
["images/player-fly-008.png", 482, 1, 0.5, 0.5,[],[]],
["images/player-fly-009.png", 503, 1, 0.5, 0.5,[],[]]
]
]
],
[
[
"Platform",
cr.behaviors.Platform
]
],
false
]
,	[
"t2",
cr.plugins_.Text,
false,
0,
null,
null,
[
],
false
]
,	[
"t3",
cr.plugins_.Sprite,
false,
0,
null,
[
[
"Default",
5,
false,
1,
0,
false,
[
["images/fireball-default-000.png", 926, 1, 0.375, 0.5,[],[-0.125,-0.25,0.125,-0.25,0.28125,-0.15625,0.375,0,0.3125,0.1875,0.125,0.28125,-0.125,0.25,-0.25,0]],
["images/fireball-default-001.png", 974, 1, 0.5, 0.5,[],[-0.25,-0.25,0,-0.25,0.15625,-0.15625,0.25,0,0.1875,0.1875,0,0.28125,-0.25,0.25,-0.375,0]],
["images/fireball-default-002.png", 1027, 1, 0.5, 0.5,[],[-0.25,-0.25,0,-0.25,0.15625,-0.15625,0.25,0,0.1875,0.1875,0,0.28125,-0.25,0.25,-0.375,0]],
["images/fireball-default-003.png", 1080, 1, 0.5, 0.5,[],[-0.25,-0.25,0,-0.25,0.15625,-0.15625,0.25,0,0.1875,0.1875,0,0.28125,-0.25,0.25,-0.375,0]],
["images/fireball-default-004.png", 904, 1, 0.5, 0.5,[],[-0.25,-0.25,0,-0.25,0.15625,-0.15625,0.25,0,0.1875,0.1875,0,0.28125,-0.25,0.25,-0.375,0]],
["images/fireball-default-005.png", 965, 1, 0.5, 0.5,[],[-0.25,-0.25,0,-0.25,0.15625,-0.15625,0.25,0,0.1875,0.1875,0,0.28125,-0.25,0.25,-0.375,0]],
["images/fireball-default-006.png", 1058, 1, 0.5, 0.5,[],[-0.25,-0.25,0,-0.25,0.15625,-0.15625,0.25,0,0.1875,0.1875,0,0.28125,-0.25,0.25,-0.375,0]],
["images/fireball-default-007.png", 1036, 1, 0.5, 0.5,[],[-0.25,-0.25,0,-0.25,0.15625,-0.15625,0.25,0,0.1875,0.1875,0,0.28125,-0.25,0.25,-0.375,0]]
]
]
],
[
[
"Bullet",
cr.behaviors.Bullet
]
,		[
"DestroyOutsideLayout",
cr.behaviors.destroy
]
],
false
]
,	[
"t4",
cr.plugins_.TiledBg,
false,
0,
["images/maintain.png", 2939],
null,
[
[
"Bullet",
cr.behaviors.Bullet
]
],
false
]
,	[
"t5",
cr.plugins_.Mouse,
false,
0,
null,
null,
[
],
false
,[]
]
,	[
"t6",
cr.plugins_.Text,
false,
0,
null,
null,
[
],
false
]
],
[
],
[
[
"Game",
1200,
320,
true,
"Game Event Sheet",
[
[
"bg",
0,
true,
[204, 255, 255],
false,
1,
1,
1,
false,
1,
[
[
[0, 154, 0, 800, 128, 0, 0, 1, 0, 0],
4,
[
],
[
[
-50,
0,
0,
0,
0
]
],
[
0,
0,
0
]
]
,			[
[800, 154, 0, 800, 128, 0, 0, 1, 0, 0],
4,
[
],
[
[
-50,
0,
0,
0,
0
]
],
[
0,
0,
0
]
]
,			[
[637, 147, 0, 32, 32, 0, 0, 1, 0.375, 0.5],
3,
[
],
[
[
-150,
0,
0,
0,
0
],
[
]
],
[
0,
0,
0
]
]
]
]
,		[
"main",
1,
true,
[255, 255, 255],
true,
1,
1,
1,
false,
1,
[
[
[0, 282, 0, 640, 38, 0, 0, 1, 0, 0],
0,
[
],
[
[
]
],
[
0,
0,
0
]
]
,			[
[120, 265, 0, 32, 32, 0, 0, 1, 0.5, 0.5],
1,
[
0,
1
],
[
[
330,
1500,
1500,
650,
1500,
1000,
0
]
],
[
0,
0,
0
]
]
,			[
[1, 1, 0, 200, 30, 0, 0, 1, 0, 0],
2,
[
],
[
],
[
"Score: 0",
0,
"14pt Arial",
"rgb(255,0,0)",
0,
0
]
]
,			[
[174, 126, 0, 296, 76, 0, 0, 1, 0, 0],
6,
[
],
[
],
[
"End Game! Please Click To Restart!",
1,
"18pt Arial",
"rgb(0,51,255)",
1,
0
]
]
]
]
],
[
]
]
],
[
[
"Game Event Sheet",
[
[
1,
"Score",
0,
0		]
,		[
0,
[true, "Player & General"],
[
[
-1,
cr.system_object.prototype.cnds.IsGroupActive,
null,
false,
false,
false,
false
,[
[
1,
[
2,
"Player & General"
]
]
]
]
],
[
]
,[
[
0,
null,
[
[
-1,
cr.system_object.prototype.cnds.OnLayoutStart,
null,
true,
false,
false,
false
]
],
[
[
-1,
cr.system_object.prototype.acts.SetVar,
null
,[
[
11,
"Score"
]
,					[
7,
[
0,
0
]
]
]
]
,				[
3,
cr.plugins_.Sprite.prototype.acts.SetY,
null
,[
[
0,
[
19,
cr.system_object.prototype.exps.random
,[
[
0,
160
]
,[
0,
270
]
]
]
]
]
]
]
]
,			[
0,
null,
[
[
5,
cr.plugins_.Mouse.prototype.cnds.OnClick,
null,
true,
false,
false,
false
,[
[
3,
0
]
,					[
3,
0
]
]
]
,				[
1,
cr.behaviors.Platform.prototype.cnds.IsOnFloor,
"Platform",
false,
false,
false,
false
]
],
[
[
1,
cr.behaviors.Platform.prototype.acts.SimulateControl,
"Platform"
,[
[
3,
2
]
]
]
]
]
,			[
0,
null,
[
[
5,
cr.plugins_.Mouse.prototype.cnds.OnClick,
null,
true,
false,
false,
false
,[
[
3,
0
]
,					[
3,
0
]
]
]
,				[
1,
cr.behaviors.Platform.prototype.cnds.IsOnFloor,
"Platform",
false,
false,
true,
false
]
,				[
1,
cr.plugins_.Sprite.prototype.cnds.IsBoolInstanceVarSet,
null,
false,
false,
true,
false
,[
[
10,
0
]
]
]
],
[
[
1,
cr.plugins_.Sprite.prototype.acts.SetAnim,
null
,[
[
1,
[
2,
"fly"
]
]
,					[
3,
1
]
]
]
,				[
1,
cr.behaviors.Platform.prototype.acts.SetVectorY,
"Platform"
,[
[
0,
[
6,
[
3,
[
22,
1,
"Platform",
cr.behaviors.Platform.prototype.exps.JumpStrength,
false,
null
]
]
,[
1,
0.666667
]
]
]
]
]
,				[
1,
cr.plugins_.Sprite.prototype.acts.SetBoolInstanceVar,
null
,[
[
10,
0
]
,					[
3,
1
]
]
]
,				[
-1,
cr.system_object.prototype.acts.AddVar,
null
,[
[
11,
"Score"
]
,					[
7,
[
0,
50
]
]
]
]
]
]
,			[
0,
null,
[
[
1,
cr.behaviors.Platform.prototype.cnds.OnLand,
"Platform",
true,
false,
false,
false
]
],
[
[
1,
cr.plugins_.Sprite.prototype.acts.SetAnim,
null
,[
[
1,
[
2,
"move"
]
]
,					[
3,
1
]
]
]
,				[
1,
cr.plugins_.Sprite.prototype.acts.SetBoolInstanceVar,
null
,[
[
10,
0
]
,					[
3,
0
]
]
]
]
]
,			[
0,
null,
[
[
5,
cr.plugins_.Mouse.prototype.cnds.OnAnyClick,
null,
true,
false,
false,
false
]
,				[
1,
cr.plugins_.Sprite.prototype.cnds.IsBoolInstanceVarSet,
null,
false,
false,
true,
false
,[
[
10,
1
]
]
]
],
[
[
-1,
cr.system_object.prototype.acts.GoToLayout,
null
,[
[
6,
"Game"
]
]
]
]
]
,			[
0,
null,
[
[
3,
cr.plugins_.Sprite.prototype.cnds.OnCollision,
null,
false,
false,
false,
true
,[
[
4,
1
]
]
]
],
[
[
1,
cr.plugins_.Sprite.prototype.acts.SetBoolInstanceVar,
null
,[
[
10,
1
]
,					[
3,
0
]
]
]
]
]
,			[
0,
null,
[
[
4,
cr.plugins_.TiledBg.prototype.cnds.CompareX,
null,
false,
false,
false,
false
,[
[
8,
3
]
,					[
0,
[
0,
-800
]
]
]
]
],
[
[
4,
cr.plugins_.TiledBg.prototype.acts.MoveForward,
null
,[
[
0,
[
0,
1600
]
]
]
]
]
]
]
]
,		[
0,
[true, "Game Tick"],
[
[
-1,
cr.system_object.prototype.cnds.IsGroupActive,
null,
false,
false,
false,
false
,[
[
1,
[
2,
"Game Tick"
]
]
]
]
],
[
]
,[
[
0,
null,
[
[
1,
cr.plugins_.Sprite.prototype.cnds.IsBoolInstanceVarSet,
null,
false,
false,
true,
false
,[
[
10,
1
]
]
]
],
[
[
1,
cr.plugins_.Sprite.prototype.acts.StopAnim,
null
]
,				[
1,
cr.behaviors.Platform.prototype.acts.SetEnabled,
"Platform"
,[
[
3,
0
]
]
]
,				[
4,
cr.behaviors.Bullet.prototype.acts.SetEnabled,
"Bullet"
,[
[
3,
0
]
]
]
,				[
3,
cr.plugins_.Sprite.prototype.acts.Destroy,
null
]
,				[
6,
cr.plugins_.Text.prototype.acts.SetVisible,
null
,[
[
3,
1
]
]
]
]
]
,			[
0,
null,
[
[
1,
cr.plugins_.Sprite.prototype.cnds.IsBoolInstanceVarSet,
null,
false,
false,
false,
false
,[
[
10,
1
]
]
]
],
[
]
,[
[
0,
null,
[
[
-1,
cr.system_object.prototype.cnds.EveryTick,
null,
false,
false,
false,
false
]
],
[
[
2,
cr.plugins_.Text.prototype.acts.SetText,
null
,[
[
7,
[
10,
[
2,
"Your Score: "
]
,[
19,
cr.system_object.prototype.exps.round
,[
[
23,
"Score"
]
]
]
]
]
]
]
,					[
-1,
cr.system_object.prototype.acts.AddVar,
null
,[
[
11,
"Score"
]
,						[
7,
[
6,
[
19,
cr.system_object.prototype.exps.dt
]
,[
0,
10
]
]
]
]
]
]
]
,				[
0,
null,
[
[
-1,
cr.system_object.prototype.cnds.Every,
null,
false,
false,
false,
false
,[
[
0,
[
1,
1
]
]
]
]
,					[
-1,
cr.system_object.prototype.cnds.Compare,
null,
false,
false,
false,
false
,[
[
7,
[
19,
cr.system_object.prototype.exps.random
,[
[
0,
0
]
,[
0,
1
]
]
]
]
,						[
8,
5
]
,						[
7,
[
1,
0.3
]
]
]
]
],
[
[
-1,
cr.system_object.prototype.acts.CreateObject,
null
,[
[
4,
3
]
,						[
5,
[
0,
1
]
]
,						[
0,
[
0,
810
]
]
,						[
0,
[
19,
cr.system_object.prototype.exps.random
,[
[
0,
160
]
,[
0,
270
]
]
]
]
]
]
]
]
]
]
]
]
]
]
],
"media/",
false,
640,
320,
0,
true,
true,
true,
"1.0"
];};

window["cr"] = cr;
window["cr"]["createRuntime"] = cr.createRuntime;
